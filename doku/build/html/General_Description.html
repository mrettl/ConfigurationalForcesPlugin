<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>Interface description &mdash; ConF3D 0.1 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="_static/css/spc-extend.css">
    <link rel="stylesheet" href="_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="genindex.html" >
    <link rel="search" title="Search" href="search.html" >
    <link rel="top" title="ConF3D 0.1 documentation" href="index.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="index.html">ConF3D 0.1 documentation</a></li>
	 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="interface-description">
<span id="id1"></span><h1>Interface description<a class="headerlink" href="#interface-description" title="Permalink to this headline">¶</a></h1>
<p><strong>Algemeine Einleitung falls jemand hier zu lesen beginnt</strong></p>
<p>The derivation of configurational forces (CF) is defined in a symbolic way for all supported element types from a small
set of governing equations.
Therefore, the user has not the burden to implement all details which are necessary to calculate CF from a
discretized FE- model. A detailed description of the symbolic derivation, including all necessary steps and used auxiliary functions
is described in <span class="xref std std-ref">_Example</span>.</p>
<p><strong>Eigentlicher Inhalt, wiederholt sich teilweise in den Examples, da auch eine generelle Beschreibung gerne überlesen wird ;)</strong></p>
<p>This section deals with the interface and describes the input and output arrays.
In contrary to the symbolic formulation, the implementations are element-dependent. Therefore, the post-processing routine has to be called
for every element type separately. The C-function <code class="code docutils literal notranslate"><span class="pre">Conf_Forces_API</span> <span class="pre">void</span> <span class="pre">Integration_{Element</span> <span class="pre">Type}_static_{mbf/dbf}</span></code> as well as the wrapped
Python function <code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">calc_Conf_Force_{Element</span> <span class="pre">Type}_static(Coords,Element_U,S_vec,PENER,SENER,method='mbf')</span></code> are calulating CFs on element nodal position.</p>
<p>To combine the CFs on the nodes from all adjacent elements, nodal unique values can be calculated by calling the C-function <code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">calc_Nodal_C</span></code> or
the Python function <code class="code docutils literal notranslate"><span class="pre">calc_Nodal</span></code>.
Note that node labels within the whole model must be unique. A part/assembly structure is therefore only possible if a node label only occurs once in a model.
In Abaqus CAE, the option “Do not use parts and assemblies in input files” is recommended to avoid this issue entirely.</p>
<p>For each element type, always two functions in C - language are generated.
To make the implementations also available in Python, a wrapper for all public functions is also automatically generated.
This wrapper also ensures to pass the inputs with the appropriate data type and shape to the C-functions.</p>
<div class="section" id="c-interface">
<h2>C - Interface<a class="headerlink" href="#c-interface" title="Permalink to this headline">¶</a></h2>
<p><strong>Inner Part of the integral</strong></p>
<p>This function calculates the inner part of the integral using the motion or displacement-based formulation within an element depending on the natural coordinates <span class="math notranslate nohighlight">\(r \, s \, t\)</span>.
It is not a public function and is only meant to be called by a numerical gauss integration function.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="p">{</span><span class="n">Element</span> <span class="n">Type</span><span class="p">}</span><span class="n">_static_</span><span class="p">{</span><span class="n">mbf</span><span class="o">/</span><span class="n">dbf</span><span class="p">}(</span><span class="kt">double</span> <span class="o">*</span><span class="n">rst</span><span class="p">,</span><span class="kt">double</span> <span class="o">*</span><span class="n">coord</span><span class="p">,</span><span class="kt">double</span> <span class="o">*</span><span class="n">Element_U</span><span class="p">,</span><span class="kt">double</span> <span class="o">*</span><span class="n">S</span><span class="p">,</span><span class="kt">double</span> <span class="n">PENER</span><span class="p">,</span>
   <span class="kt">double</span> <span class="n">SENER</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">res_0</span><span class="p">)</span>

<span class="cm">/*</span>
<span class="cm">double *rst :        array of size 3</span>
<span class="cm">                     natural coordinates, where the function is evaluated.</span>

<span class="cm">double *coord :      array of size number_of_nodes*3</span>
<span class="cm">                     global nodal coordinates of the element in the order(N1_x,N1_y,N1_z,N2_x,...)</span>

<span class="cm">double *Element_U :  array of size number_of_nodes*3</span>
<span class="cm">                     displacement on the element nodes in the order (U1_x,U1_y,U1_z,U2_x,...)</span>

<span class="cm">double *S :          array of size number_of_integration_points*6</span>
<span class="cm">                     chauchy stress at integration points (S1_11,S1_22,S1_33,S1_12,S1_13,S1_23,S2_11,...)</span>

<span class="cm">double PENER :       value</span>
<span class="cm">                     plastic energy density at an integration point</span>

<span class="cm">double SENER :       value</span>
<span class="cm">                     elastic energy density at an integration point</span>

<span class="cm">double *res_0 :      array of size 3</span>
<span class="cm">                     result on the evaluated on the given natural coordinates</span>
<span class="cm">*/</span>
</pre></div>
</div>
<p><strong>Calculation of configurational forces</strong></p>
<p>This function calculates the configurational forces at element nodal position, by using gauss integration. The integration points and weights
are hard-coded, therefore it isn’t necessary to pass them to the function.
This is a public function and exported from the shared library.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Conf_Forces_API</span> <span class="kt">void</span> <span class="n">Integration_</span><span class="p">{</span><span class="n">Element</span> <span class="n">Type</span><span class="p">}</span><span class="n">_static_</span><span class="p">{</span><span class="n">mbf</span><span class="o">/</span><span class="n">dbf</span><span class="p">}(</span><span class="kt">size_t</span> <span class="n">num_elem</span><span class="p">,</span><span class="kt">double</span> <span class="n">Coords</span><span class="p">[][</span><span class="mi">4</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span>
   <span class="kt">double</span> <span class="n">Element_U</span><span class="p">[][</span><span class="n">_</span><span class="p">][</span><span class="n">_</span><span class="p">],</span> <span class="kt">double</span> <span class="n">S</span><span class="p">[][</span><span class="n">_</span><span class="p">][</span><span class="mi">6</span><span class="p">],</span><span class="kt">double</span> <span class="n">PENER</span><span class="p">[][</span><span class="n">_</span><span class="p">],</span><span class="kt">double</span> <span class="n">SENER</span><span class="p">[][</span><span class="n">_</span><span class="p">],</span><span class="kt">double</span> <span class="n">Conf_Force</span><span class="p">[][</span><span class="n">_</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

<span class="cm">/*</span>
<span class="cm">size_t num_elem :          value</span>
<span class="cm">                           number of elements</span>

<span class="cm">double Coords[][_][_] :    array with shape [number_of_elements][number_of_nodes_per_element][3]</span>
<span class="cm">                           global nodal coordinates of the elements</span>

<span class="cm">double Element_U[][_][_] : array with shape [number_of_elements][number_of_nodes_per_element][3]</span>
<span class="cm">                           displacement at the element nodes</span>

<span class="cm">double S[][_][_] :         array of shape [number_of_elements][number_of_integration_points][6]</span>
<span class="cm">                           chauchy stress at integration points</span>
<span class="cm">                           stress tensor in the order of(S1_11,S1_22,S1_33,S1_12,S1_13,S1_23)</span>

<span class="cm">double PENER[][4] :        array of shape [number_of_elements][number_of_integration_points]</span>
<span class="cm">                           plastic energy density at integration points</span>

<span class="cm">double SENER[][4] :        array of shape [number_of_elements][number_of_integration_points]</span>
<span class="cm">                           elastic energy density at integration points</span>

<span class="cm">double Conf_Force[][_][3]: array of shape [number_of_elements][number_of_nodes_per_element][3]</span>
<span class="cm">                           configurational forces at element nodal position</span>
<span class="cm">*/</span>
</pre></div>
</div>
<p><strong>Calculation of nodal unique values</strong></p>
<p>The previous functions are, as already mentioned, element type dependent and calculated on element nodal position.
To get the final result at a node, all contributions from elements which share a node have to be summed up.
The array <code class="code docutils literal notranslate"><span class="pre">inverse</span> <span class="pre">defines</span></code> how to reconstruct an array of node labels from an array of unique node labels.
In Numpy this can be accomplished by <code class="code docutils literal notranslate"><span class="pre">unique_arr,inverse</span> <span class="pre">=</span> <span class="pre">np.unique(ar,return_inverse=True)</span></code></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Conf_Forces_API</span> <span class="kt">void</span> <span class="n">calc_Nodal_C</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">num_elem_nodal</span><span class="p">,</span><span class="kt">double</span> <span class="n">CF_out</span><span class="p">[][</span><span class="mi">3</span><span class="p">],</span><span class="kt">double</span> <span class="n">CF</span><span class="p">[][</span><span class="mi">3</span><span class="p">],</span><span class="kt">int64_t</span> <span class="n">inverse</span><span class="p">[])</span>

<span class="cm">/*</span>
<span class="cm">size_t num_elem :          value</span>
<span class="cm">                           number of elements</span>

<span class="cm">double CF_out[][3] :       array with shape [number_of_unique_nodelabels][3]</span>
<span class="cm">                           nodal unique values (Output)</span>

<span class="cm">double CF[][3] :           array with shape [number_of_elements*number_of_nodes_per_element][3]</span>
<span class="cm">                           values at element nodal position (Input)</span>

<span class="cm">int64_t inverse[] :        array of shape [number_of_elements*number_of_nodes_per_element]</span>
<span class="cm">                           array of indices which reconstructs the element nodal node labels from unique</span>
<span class="cm">                           node labels</span>
<span class="cm">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="python-interface">
<h2>Python - Interface<a class="headerlink" href="#python-interface" title="Permalink to this headline">¶</a></h2>
<p>All Python functions are just wrappers for the corresponding C-functions. The only dependencies are ctypes, which is a standard Python package,
and NumPy. This also ensures that this code is usable with a wide range of Python versions. The interface is tested on Linux and Windows operating systems.
As with the C-functions above, there is a separate function for all supported element-types.
All input arrays are checked for consistancy (array-shape) and the appropriate data type is ensured.</p>
<p><strong>Calculation of configurational forces</strong></p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calc_Conf_Force_</span><span class="p">{</span><span class="n">Element</span> <span class="n">Type</span><span class="p">}</span><span class="n">_static</span><span class="p">(</span><span class="n">Coords</span><span class="p">,</span><span class="n">Element_U</span><span class="p">,</span><span class="n">S_vec</span><span class="p">,</span><span class="n">PENER</span><span class="p">,</span><span class="n">SENER</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;mbf&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        Coords : (num_elem,numNodes,3) nd-array</span>
<span class="sd">            global nodal coordinates of the elements</span>
<span class="sd">        Element_U : (num_elem,numNodes,3) nd-array</span>
<span class="sd">            displacement at the element nodes</span>
<span class="sd">        S_vec : (num_elem,num_int_points,6) nd-array</span>
<span class="sd">            chauchy stress at integration points</span>
<span class="sd">            stress tensor in the order of(S11,S22,S33,S12,S13,S23)</span>
<span class="sd">        PENER : (num_elem,num_int_points) nd-array</span>
<span class="sd">            plastic energy density at integration points</span>
<span class="sd">        SENER : (num_elem,num_int_points) nd-array</span>
<span class="sd">            elastic energy density at integration points</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Conf_Force : (number_of_elements,number_of_nodes_per_element,3) nd-array</span>
<span class="sd">          configurational forces at element nodal position</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p><strong>Calculation of nodal unique values</strong></p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calc_Nodal</span><span class="p">(</span><span class="n">Element_Connectivity</span><span class="p">,</span><span class="n">CF</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Element_Connectivity : list of nd-arrays or nd-array</span>
<span class="sd">        connectivity of the element nodal position as nd-array, if multiple elements</span>
<span class="sd">        should be evaluated a list of nd-arrays must be passed</span>
<span class="sd">    CF_in : list of np.arrays or np.array</span>
<span class="sd">        configurational forces at element nodal position as nd-array,</span>
<span class="sd">        if multiple elements should be evaluated</span>
<span class="sd">        a list of nd-arrays must be passed</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Node_labels : (number_of_unique_nodes) nd-array</span>
<span class="sd">        node labels coresponding to the CF_out array bellow</span>
<span class="sd">    CF_out : (number_of_unique_nodes,3) nd-array</span>
<span class="sd">        configurational forces at nodes</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Interface description</a><ul>
<li><a class="reference internal" href="#c-interface">C - Interface</a></li>
<li><a class="reference internal" href="#python-interface">Python - Interface</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <div>
    <a href="_sources/General_description.rst.txt"
       rel="nofollow">Show Source</a>
  </div>
        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2022, Markus Tauscher.
      </li>
      <li>
      Created using <a href="https://www.sphinx-doc.org">Sphinx</a> 3.0.3.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>