<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>API description &mdash; ConF3D 0.1 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="_static/css/spc-extend.css">
    <link rel="stylesheet" href="_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="genindex.html" >
    <link rel="search" title="Search" href="search.html" >
    <link rel="top" title="ConF3D 0.1 documentation" href="index.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="index.html">ConF3D 0.1 documentation</a></li>
	 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="api-description">
<span id="interface-description"></span><h1>API description<a class="headerlink" href="#api-description" title="Permalink to this headline">¶</a></h1>
<p><span class="math notranslate nohighlight">\(\newcommand{\mytensor}[1] {\boldsymbol{\mathrm{#1}}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\myjaci}[2]   {\displaystyle \sum^i\frac{\partial \mathrm{N}^{\,i}}{\partial #2} #1^{\,i}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\mynderiv}[2] {\displaystyle \frac{\partial\mathrm{N}^{#1}}{\partial\mathrm{r}_{#2}}}\)</span></p>
<p>The derivation of configurational forces (CF) is defined in a symbolic way for all supported element types from a small
set of governing equations shown bellow. For a detailed description of the derivation have a look at <a class="reference internal" href="Example.html#example"><span class="std std-ref">Symbolic implementation of configurational forces</span></a>.</p>
<p><span class="math notranslate nohighlight">\(\mytensor{g}=\int_{V}{\frac{\partial\mytensor{N}}{\partial\mytensor{x}}{\mytensor{C}}^\mathrm{T}}\det\left(\mytensor{J}\right)dV\)</span></p>
<p><span class="math notranslate nohighlight">\(\mytensor{C} = \phi\mytensor{I}-\mytensor{F}^\mathrm{T}\mytensor{S}\)</span></p>
<p>Therefore, the users does not need to implement all details which are necessary to calculate CF from a
discretized FE- model themselves. A detailed description of the symbolic derivation, including all necessary steps and used auxiliary functions
is described in <a class="reference internal" href="Example.html#example"><span class="std std-ref">Symbolic implementation of configurational forces</span></a>.</p>
<p>This section deals with the interface and describes the input and output arrays.
In contrary to the symbolic formulation, the numerical implementations are element-dependent.
All element-specific functions are depending on the respective shape functions and expression derived from it, like the Jacobian.</p>
<p>Therefore, the post-processing routine has to be called for every element type separately.
The C-function <code class="code docutils literal notranslate"><span class="pre">Conf_Forces_API</span> <span class="pre">void</span> <span class="pre">Integration_{Element</span> <span class="pre">Type}_static_{mbf/dbf}</span></code> as well as the wrapped
Python function <code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">calc_Conf_Force_{Element</span> <span class="pre">Type}_static(Coords,Element_U,S_vec,PENER,SENER,method='mbf')</span></code> are evaluating CFs on element nodal position.</p>
<p>To combine the nodal CFs from all adjacent elements, nodal unique values can be calculated by calling the C-function <code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">calc_Nodal_C</span></code> or
the Python function <code class="code docutils literal notranslate"><span class="pre">calc_Nodal</span></code>.
Note that node labels within the whole model must be unique. A part/assembly structure is therefore only possible if a node label only occurs once in a model.
In Abaqus CAE, the option “Do not use parts and assemblies in input files” is recommended to avoid this issue entirely.</p>
<p>For each element type, two functions in C - language are generated.
To make the implementations also available in Python, a wrapper for all public functions is automatically generated.
This wrapper also ensures to pass the inputs with the appropriate data type and shape to the C-functions.
First, the Python-API is explained below, followed by the C API.</p>
<div class="section" id="python-interface">
<h2>Python - Interface<a class="headerlink" href="#python-interface" title="Permalink to this headline">¶</a></h2>
<p>All Python functions are just wrappers for the corresponding C-functions. The only dependencies are ctypes, which is a standard Python package,
and NumPy. This also ensures that this code is usable with a wide range of Python versions. The interface has been tested on Linux and Windows operating systems.
As with the C-functions below, there is a separate function for all supported element types.
All input arrays are checked for consistancy (array-shape) and the appropriate data type is ensured before calling the C-API.</p>
<p><strong>Calculation of configurational forces</strong></p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calc_Conf_Force_</span><span class="p">{</span><span class="n">Element</span> <span class="n">Type</span><span class="p">}</span><span class="n">_static</span><span class="p">(</span><span class="n">Coords</span><span class="p">,</span><span class="n">Element_U</span><span class="p">,</span><span class="n">S_vec</span><span class="p">,</span><span class="n">PENER</span><span class="p">,</span><span class="n">SENER</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;mbf&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        Coords : (num_elem,numNodes,3) nd-array</span>
<span class="sd">            global nodal coordinates of the elements</span>
<span class="sd">        Element_U : (num_elem,numNodes,3) nd-array</span>
<span class="sd">            displacement at the element nodes</span>
<span class="sd">        S_vec : (num_elem,num_int_points,6) nd-array</span>
<span class="sd">            chauchy stress at integration points</span>
<span class="sd">            stress tensor in the order of(S11,S22,S33,S12,S13,S23)</span>
<span class="sd">        PENER : (num_elem,num_int_points) nd-array</span>
<span class="sd">            plastic energy density at integration points</span>
<span class="sd">        SENER : (num_elem,num_int_points) nd-array</span>
<span class="sd">            elastic energy density at integration points</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        Conf_Force : (number_of_elements,number_of_nodes_per_element,3) nd-array</span>
<span class="sd">          configurational forces at element nodal position</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p><strong>Calculation of nodal unique values</strong></p>
<p>As already mentioned, the function call <code class="code docutils literal notranslate"><span class="pre">calc_Conf_Force_{Element</span> <span class="pre">type}</span></code> is element-dependent.
If there are multiple element types in the model, the corresponding function for each element type has to be called seperately.
To combine the CFs on the nodes from all adjecent elements, nodal unique values can be calculated by calling the function <code class="code docutils literal notranslate"><span class="pre">calc_Nodal</span></code>.
This function accepts both Numpy nd-arrays if only one element type is present in the model or a list of Numpy nd-arrays for multiple element types. Note that node labels within the model must be unique.
A part/assembly structure is therefore only possible if a node label only occurs once in a model.
In Abaqus CAE, the option “Do not use parts and assemblies in input files” is recommended to avoid this issue entirely.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calc_Nodal</span><span class="p">(</span><span class="n">Element_Connectivity</span><span class="p">,</span><span class="n">CF</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Element_Connectivity : list of nd-arrays or nd-array</span>
<span class="sd">        connectivity of the element nodal position as nd-array, if multiple elements</span>
<span class="sd">        should be evaluated a list of nd-arrays must be passed</span>
<span class="sd">    CF_in : list of np.arrays or np.array</span>
<span class="sd">        configurational forces at element nodal position as nd-array,</span>
<span class="sd">        if multiple elements should be evaluated</span>
<span class="sd">        a list of nd-arrays must be passed</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Node_labels : (number_of_unique_nodes) nd-array</span>
<span class="sd">        node labels coresponding to the CF_out array bellow</span>
<span class="sd">    CF_out : (number_of_unique_nodes,3) nd-array</span>
<span class="sd">        configurational forces at nodes</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="c-interface">
<h2>C - Interface<a class="headerlink" href="#c-interface" title="Permalink to this headline">¶</a></h2>
<p><strong>Inner Part of the configurational forces integral</strong></p>
<p>This function calculates the inner part of the configurational forces integral <span class="math notranslate nohighlight">\(\mytensor{f}\)</span>
using the motion or displacement-based formulation within an element depending on the natural coordinates <span class="math notranslate nohighlight">\(r , s , t\)</span>.</p>
<p><span class="math notranslate nohighlight">\(\mytensor{f} = \displaystyle \frac{\partial\mytensor{N}}{\partial\mytensor{x}} \, \mytensor{C}^\mathrm{T} \, \mathrm{det}(\mytensor{J})\)</span></p>
<p>It is not a public function and is only meant to be called by a numerical gauss integration function.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="p">{</span><span class="n">Element</span> <span class="n">Type</span><span class="p">}</span><span class="n">_static_</span><span class="p">{</span><span class="n">mbf</span><span class="o">/</span><span class="n">dbf</span><span class="p">}(</span><span class="kt">double</span> <span class="o">*</span><span class="n">rst</span><span class="p">,</span><span class="kt">double</span> <span class="o">*</span><span class="n">coord</span><span class="p">,</span><span class="kt">double</span> <span class="o">*</span><span class="n">Element_U</span><span class="p">,</span><span class="kt">double</span> <span class="o">*</span><span class="n">S</span><span class="p">,</span><span class="kt">double</span> <span class="n">PENER</span><span class="p">,</span>
   <span class="kt">double</span> <span class="n">SENER</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">res_0</span><span class="p">)</span>

<span class="cm">/*</span>
<span class="cm">double *rst :        array of size 3</span>
<span class="cm">                     natural coordinates, where the function is evaluated.</span>

<span class="cm">double *coord :      array of size number_of_nodes*3</span>
<span class="cm">                     global nodal coordinates of the element in the order(N1_x,N1_y,N1_z,N2_x,...)</span>

<span class="cm">double *Element_U :  array of size number_of_nodes*3</span>
<span class="cm">                     displacement of the element nodes in the order (U1_x,U1_y,U1_z,U2_x,...)</span>

<span class="cm">double *S :          array of size number_of_integration_points*6</span>
<span class="cm">                     chauchy stress at integration points (S1_11,S1_22,S1_33,S1_12,S1_13,S1_23,S2_11,...)</span>

<span class="cm">double PENER :       value</span>
<span class="cm">                     plastic energy density at an integration point</span>

<span class="cm">double SENER :       value</span>
<span class="cm">                     elastic energy density at an integration point</span>

<span class="cm">double *res_0 :      array of size 3</span>
<span class="cm">                     result of the inner part of the integral</span>
<span class="cm">                     evaluated at given natural coordinates</span>
<span class="cm">*/</span>
</pre></div>
</div>
<p><strong>Calculation of configurational forces</strong></p>
<p>This element-specic function calculates the configurational forces at element nodal position by using Gauss integration. The integration points and weights
are hard-coded, therefore it isn’t necessary to pass them to the function.
This is a public function and exported from the shared library.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Conf_Forces_API</span> <span class="kt">void</span> <span class="n">Integration_</span><span class="p">{</span><span class="n">Element</span> <span class="n">Type</span><span class="p">}</span><span class="n">_static_</span><span class="p">{</span><span class="n">mbf</span><span class="o">/</span><span class="n">dbf</span><span class="p">}(</span><span class="kt">size_t</span> <span class="n">num_elem</span><span class="p">,</span><span class="kt">double</span> <span class="n">Coords</span><span class="p">[][</span><span class="mi">4</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span>
   <span class="kt">double</span> <span class="n">Element_U</span><span class="p">[][</span><span class="n">_</span><span class="p">][</span><span class="n">_</span><span class="p">],</span> <span class="kt">double</span> <span class="n">S</span><span class="p">[][</span><span class="n">_</span><span class="p">][</span><span class="mi">6</span><span class="p">],</span><span class="kt">double</span> <span class="n">PENER</span><span class="p">[][</span><span class="n">_</span><span class="p">],</span><span class="kt">double</span> <span class="n">SENER</span><span class="p">[][</span><span class="n">_</span><span class="p">],</span><span class="kt">double</span> <span class="n">Conf_Force</span><span class="p">[][</span><span class="n">_</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

<span class="cm">/*</span>
<span class="cm">size_t num_elem :          value</span>
<span class="cm">                           number of elements</span>

<span class="cm">double Coords[][_][_] :    array with shape [number_of_elements][number_of_nodes_per_element][3]</span>
<span class="cm">                           global nodal coordinates of the elements</span>

<span class="cm">double Element_U[][_][_] : array with shape [number_of_elements][number_of_nodes_per_element][3]</span>
<span class="cm">                           displacement at the element nodes</span>

<span class="cm">double S[][_][_] :         array of shape [number_of_elements][number_of_integration_points][6]</span>
<span class="cm">                           chauchy stress at integration points</span>
<span class="cm">                           stress tensor in the order of(S1_11,S1_22,S1_33,S1_12,S1_13,S1_23)</span>

<span class="cm">double PENER[][4] :        array of shape [number_of_elements][number_of_integration_points]</span>
<span class="cm">                           plastic energy density at integration points</span>

<span class="cm">double SENER[][4] :        array of shape [number_of_elements][number_of_integration_points]</span>
<span class="cm">                           elastic energy density at integration points</span>

<span class="cm">double Conf_Force[][_][3]: array of shape [number_of_elements][number_of_nodes_per_element][3]</span>
<span class="cm">                           configurational forces at element nodal position</span>
<span class="cm">*/</span>
</pre></div>
</div>
<p><strong>Calculation of unique nodal values</strong></p>
<p>As already mentioned, the function call <code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">Integration_{Element</span> <span class="pre">Type}_static_{mbf/dbf}</span></code> is element-dependent.
If there are multiple element types in the model, the corresponding function for each element type has to be called seperately.
To combine the CFs on the nodes from all adjecent elements, nodal unique values can be calculated by calling the function <code class="code docutils literal notranslate"><span class="pre">void</span> <span class="pre">calc_Nodal_C</span></code>.</p>
<p>The array <code class="code docutils literal notranslate"><span class="pre">int64_t</span> <span class="pre">inverse[]</span></code> defines how to reconstruct an element-connectivity array from an array of unique node labels.
If there are multiple element-types in the model, the element connectivity arrays and the element nodal configurational force vectors of all elements have to be concatenated.
In NumPy the inverse array can be created by <code class="code docutils literal notranslate"><span class="pre">unique_arr,inverse</span> <span class="pre">=</span> <span class="pre">np.unique(ar,return_inverse=True)</span></code>.</p>
<p>A part/assembly structure is therefore only possible if a node label only occurs once in a model.
In Abaqus CAE, the option “Do not use parts and assemblies in input files” is recommended to avoid this issue entirely.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Conf_Forces_API</span> <span class="kt">void</span> <span class="n">calc_Nodal_C</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">num_elem_nodal</span><span class="p">,</span><span class="kt">double</span> <span class="n">CF_out</span><span class="p">[][</span><span class="mi">3</span><span class="p">],</span><span class="kt">double</span> <span class="n">CF</span><span class="p">[][</span><span class="mi">3</span><span class="p">],</span><span class="kt">int64_t</span> <span class="n">inverse</span><span class="p">[])</span>

<span class="cm">/*</span>
<span class="cm">size_t num_elem :          value</span>
<span class="cm">                           number of elements</span>

<span class="cm">double CF_out[][3] :       array with shape [number_of_unique_nodelabels][3]</span>
<span class="cm">                           nodal unique values (Output)</span>

<span class="cm">double CF[][3] :           array with shape [number_of_elements*number_of_nodes_per_element][3]</span>
<span class="cm">                           values at element nodal position (Input)</span>

<span class="cm">int64_t inverse[] :        array of shape [number_of_elements*number_of_nodes_per_element]</span>
<span class="cm">                           array of indices which reconstructs the element nodal node labels from unique</span>
<span class="cm">                           node labels</span>
<span class="cm">*/</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">API description</a><ul>
<li><a class="reference internal" href="#python-interface">Python - Interface</a></li>
<li><a class="reference internal" href="#c-interface">C - Interface</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <div>
    <a href="_sources/General_description.rst.txt"
       rel="nofollow">Show Source</a>
  </div>
        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2022, Markus Tauscher.
      </li>
      <li>
      Created using <a href="https://www.sphinx-doc.org">Sphinx</a> 3.0.3.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>