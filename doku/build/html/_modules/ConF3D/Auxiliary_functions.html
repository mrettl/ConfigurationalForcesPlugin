<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>ConF3D.Auxiliary_functions &mdash; ConF3D 0.1 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="../../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" >
    <link rel="search" title="Search" href="../../search.html" >
    <link rel="top" title="ConF3D 0.1 documentation" href="../../index.html" >
    <link rel="up" title="Module code" href="../index.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="../../index.html">ConF3D 0.1 documentation</a></li>
	
          <li class="active"><a href="../index.html" accesskey="U">Module code</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <h1>Source code for ConF3D.Auxiliary_functions</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Auxilliar functions</span>
<span class="sd">======================</span>

<span class="sd">In this module all auxilliar functions are defined. The basic functionalities are:</span>

<span class="sd">- Generating symbolic shape functions (Poly_coefs, generate_shape_func_coeff, get_shapeFunc)</span>
<span class="sd">- Generating numeric matrices and Tensors (create_sym_Mat,gen_2D_Ten_from_Vec)</span>
<span class="sd">- Analytical helper functions (get_jac, get_val_at_int_Pkt, get_det_and_inv, calc_dN_rst)</span>
<span class="sd">- Code generation of analytical expressions (lambdify_numba, lambdify_C)</span>
<span class="sd">- Generating wrappers and headers (gen_C_header, gen_Integration_C_static, gen_Python_Wrapper_static)</span>
<span class="sd">- C-code generation including integation(gen_Configurational_Forces_Static)</span>


<span class="sd">Exmaple for generation of a implementation of Configurational forces</span>
<span class="sd">======================</span>

<span class="sd">**Calculation of the shape function coefficients**</span>

<span class="sd">    &gt;&gt;&gt; shapeFuncCoef_bild,shapeFuncCoef_int,shapeFuncCoef_bild_diff,shapeFuncCoef_int_diff=\</span>
<span class="sd">    &gt;&gt;&gt; generate_shape_func_coeff(bild_points,int_points,poly_power)</span>

<span class="sd">**Definitions of neccesary symbols**</span>

<span class="sd">    &gt;&gt;&gt; num_nodes      = shapeFuncCoef_bild.shape[0]</span>
<span class="sd">    &gt;&gt;&gt; num_int_points = int_points.shape[0]</span>
<span class="sd">    &gt;&gt;&gt; r, s, t        = sy.symbols(&quot;r s t&quot;)</span>
<span class="sd">    &gt;&gt;&gt; rst            = sy.Matrix((r, s, t))</span>
<span class="sd">    &gt;&gt;&gt; coord          = sy.MatrixSymbol(&#39;coord&#39;, num_nodes, 3)</span>
<span class="sd">    &gt;&gt;&gt; Element_U      = sy.MatrixSymbol(&#39;U&#39;, num_nodes, 3)</span>
<span class="sd">    &gt;&gt;&gt; SENER,PENER    = sy.symbols(&quot;SENER PENER&quot;)</span>
<span class="sd">    &gt;&gt;&gt; S_Ten          = sy.symbols(&quot;S11 S22 S33 S12 S13 S23&quot;)</span>

<span class="sd">:math:`\newcommand{\mytensor}[1] {\boldsymbol{\mathrm{#1}}}`</span>


<span class="sd">**Generation of shape functions**</span>

<span class="sd">Definition of symbolic shape functions for the defined element.</span>

<span class="sd">:math:`\mytensor{N}=\left[\begin{array}{ccc}N_1 \\ \vdots \\ N_i \end{array}\right]`</span>
<span class="sd"> </span>
<span class="sd"> &gt;&gt;&gt; shapeFunc=get_shapeFunc(shapeFuncCoef_bild,r,s,t)</span>


<span class="sd">**Calculation of the Jacobian matrix**</span>

<span class="sd">    &gt;&gt;&gt; shapeFunc=get_shapeFunc(shapeFuncCoef_bild,r,s,t)</span>


<span class="sd">:math:`\boldsymbol{\mathrm{P}} = \mathrm{det}(\boldsymbol{\mathrm{F}}) \,\boldsymbol{\mathrm{F}}^{-1}\,\boldsymbol{\mathrm{S}}\label{eq:meineerste}`</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sy</span>
<span class="kn">import</span> <span class="nn">numpy.polynomial.polynomial</span> <span class="k">as</span> <span class="nn">pol</span>


<div class="viewcode-block" id="Poly_coefs"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.Poly_coefs.html#ConF3D.Auxiliary_functions.Poly_coefs">[docs]</a><span class="k">def</span> <span class="nf">Poly_coefs</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">poly_power</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the coefficients of the shape functions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : (number of nodes,3) nd-array</span>
<span class="sd">        Coordinates of nodes</span>
<span class="sd">    poly_power : (at least number of nodes,3) nd-array</span>
<span class="sd">        Polynomial coefficents of shape functions in 3 dimensional space</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coef : (number of points, r coeff, s coeff, t coeff) nd-array</span>
<span class="sd">        Coefficents of shape functions;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_points</span><span class="o">=</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">num_Power</span><span class="o">=</span><span class="n">poly_power</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1">#ignore higher polynomial roders if there are not sufficent nodes</span>
    <span class="n">Dim</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_points</span><span class="p">,</span><span class="n">num_Power</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_points</span><span class="p">,</span><span class="n">Dim</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_points</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dim</span><span class="p">):</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">poly_power</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="n">poly_power</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="n">poly_power</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="n">coef</span><span class="o">=</span><span class="p">[]</span>
    
    <span class="c1">#Get solution for every Node</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_points</span><span class="p">):</span>
        <span class="n">coef_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">poly_power</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Erg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
        <span class="n">Erg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="n">Loes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">Erg</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Dim</span><span class="p">):</span>
            <span class="n">coef_i</span><span class="p">[</span><span class="n">poly_power</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">poly_power</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">poly_power</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Loes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">coef</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coef_i</span><span class="p">)</span>
    
    <span class="c1">#eg:(4, 2, 2, 1)</span>
    <span class="c1">#(pkt_num,x,y,z)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coef</span><span class="p">)</span></div>

<div class="viewcode-block" id="generate_shape_func_coeff"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.generate_shape_func_coeff.html#ConF3D.Auxiliary_functions.generate_shape_func_coeff">[docs]</a><span class="k">def</span> <span class="nf">generate_shape_func_coeff</span><span class="p">(</span><span class="n">bild_points</span><span class="p">,</span><span class="n">int_points</span><span class="p">,</span><span class="n">poly_power</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the coefficients of the shape functions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bild_points : (number of nodes,3) nd-array</span>
<span class="sd">        Coordinates of nodes</span>
<span class="sd">    int_points_points : (number of points, 3) nd-array</span>
<span class="sd">        Polynomial coefficents of shape functions in 3 dimensional space</span>
<span class="sd">    poly_power: (numpy-polynomial)</span>
<span class="sd">        Shape functions</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    shapeFuncCoef_bild :        (number of nodes,num_Coef_r,num_Coef_s,num_Coef_t) nd-array</span>
<span class="sd">        Coefficents of shape functions at nodes</span>
<span class="sd">    shapeFuncCoef_int :         (number of points,num_Coef_r,num_Coef_s,num_Coef_t) nd-array</span>
<span class="sd">        Coefficents of shape functions at integration points</span>
<span class="sd">    shapeFuncCoef_bild_diff :   (number of nodes,3,num_Coef_r,num_Coef_s,num_Coef_t) nd-array</span>
<span class="sd">        Coefficents of derived shape functions at nodes</span>
<span class="sd">    shapeFuncCoef_int_diff :    (number of points,3,num_Coef_r,num_Coef_s,num_Coef_t) nd-array</span>
<span class="sd">        Coefficents of derived shape functions at integration points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">## Calculate shape functions</span>
    <span class="n">shapeFuncCoef_bild</span> <span class="o">=</span> <span class="n">Poly_coefs</span><span class="p">(</span><span class="n">bild_points</span><span class="p">,</span><span class="n">poly_power</span><span class="p">)</span>
    <span class="n">shapeFuncCoef_int</span>  <span class="o">=</span> <span class="n">Poly_coefs</span><span class="p">(</span><span class="n">int_points</span><span class="p">,</span><span class="n">poly_power</span><span class="p">)</span>
    
    <span class="n">num_bild_pts</span><span class="o">=</span><span class="n">bild_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">num_int_pts</span> <span class="o">=</span><span class="n">int_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">shape_coef_bild</span><span class="o">=</span><span class="n">shapeFuncCoef_bild</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">shape_coef_int</span> <span class="o">=</span><span class="n">shapeFuncCoef_int</span><span class="o">.</span><span class="n">shape</span>
    
    <span class="c1">## Calculate derivivative of shape functions</span>
    <span class="c1"># nodes</span>
    <span class="n">shapeFuncCoef_bild_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_bild_pts</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">shape_coef_bild</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">shape_coef_bild</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">shape_coef_bild</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bild_pts</span><span class="p">):</span>
        <span class="n">coef</span><span class="o">=</span><span class="n">shapeFuncCoef_bild</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">dcoef_dx</span> <span class="o">=</span> <span class="n">pol</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dcoef_dy</span> <span class="o">=</span> <span class="n">pol</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dcoef_dz</span> <span class="o">=</span> <span class="n">pol</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">shapeFuncCoef_bild_diff</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,:</span><span class="n">dcoef_dx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],:</span><span class="n">dcoef_dx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],:</span><span class="n">dcoef_dx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">=</span><span class="n">dcoef_dx</span>
        <span class="n">shapeFuncCoef_bild_diff</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,:</span><span class="n">dcoef_dy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],:</span><span class="n">dcoef_dy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],:</span><span class="n">dcoef_dy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">=</span><span class="n">dcoef_dy</span>
        <span class="n">shapeFuncCoef_bild_diff</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">,:</span><span class="n">dcoef_dz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],:</span><span class="n">dcoef_dz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],:</span><span class="n">dcoef_dz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">=</span><span class="n">dcoef_dz</span>
    
    <span class="c1"># integration points</span>
    <span class="n">shapeFuncCoef_int_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_int_pts</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">shape_coef_int</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">shape_coef_int</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">shape_coef_int</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_int_pts</span><span class="p">):</span>
        <span class="n">coef</span><span class="o">=</span><span class="n">shapeFuncCoef_int</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">dcoef_dx</span> <span class="o">=</span> <span class="n">pol</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dcoef_dy</span> <span class="o">=</span> <span class="n">pol</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dcoef_dz</span> <span class="o">=</span> <span class="n">pol</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">coef</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">shapeFuncCoef_int_diff</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,:</span><span class="n">dcoef_dx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],:</span><span class="n">dcoef_dx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],:</span><span class="n">dcoef_dx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">=</span><span class="n">dcoef_dx</span>
        <span class="n">shapeFuncCoef_int_diff</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,:</span><span class="n">dcoef_dy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],:</span><span class="n">dcoef_dy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],:</span><span class="n">dcoef_dy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">=</span><span class="n">dcoef_dy</span>
        <span class="n">shapeFuncCoef_int_diff</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="p">,:</span><span class="n">dcoef_dz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],:</span><span class="n">dcoef_dz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],:</span><span class="n">dcoef_dz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">=</span><span class="n">dcoef_dz</span>
    
    <span class="n">shapeFuncCoef_bild</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">shapeFuncCoef_bild</span><span class="p">),</span><span class="mi">0</span><span class="p">)]</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">return</span> <span class="n">shapeFuncCoef_bild</span><span class="p">,</span><span class="n">shapeFuncCoef_int</span><span class="p">,</span><span class="n">shapeFuncCoef_bild_diff</span><span class="p">,</span><span class="n">shapeFuncCoef_int_diff</span></div>

<div class="viewcode-block" id="create_sym_Mat"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.create_sym_Mat.html#ConF3D.Auxiliary_functions.create_sym_Mat">[docs]</a><span class="k">def</span> <span class="nf">create_sym_Mat</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">shape_0</span><span class="p">,</span><span class="n">shape_1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creation of a symbolic matrix</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of symbols</span>
<span class="sd">    shape_0 : int</span>
<span class="sd">        Shape 0 of the matrix</span>
<span class="sd">    shape_1 : int</span>
<span class="sd">        Shape 1 of the matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sym_Mat : symPy Matrix</span>
<span class="sd">        Symbolic matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sym_Mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">shape_0</span><span class="p">,</span><span class="n">shape_1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shape_0</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shape_1</span><span class="p">):</span>
            <span class="n">sym_Mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">sym_Mat</span><span class="p">)</span></div>

<div class="viewcode-block" id="gen_2D_Ten_from_vec"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.gen_2D_Ten_from_vec.html#ConF3D.Auxiliary_functions.gen_2D_Ten_from_vec">[docs]</a><span class="k">def</span> <span class="nf">gen_2D_Ten_from_vec</span><span class="p">(</span><span class="n">Vec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a Second order Tensor from vector notation.</span>

<span class="sd">    This function is Abaqus specific. </span>
<span class="sd">    eg. vector notation of the stress tensor:</span>
<span class="sd">    (S11,S22,S33,S12,S13,S23)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Vec : (6) nd-array consisting of SymPy symbols or SymPy matrix</span>
<span class="sd">        Second order tensor in vector notation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S_Ten : SymPy matrix</span>
<span class="sd">        Second order tensor (sympy matrix object)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S_Ten</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">))</span>
    
    <span class="n">S_Ten</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">Vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">S_Ten</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">Vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">S_Ten</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">Vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">S_Ten</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">Vec</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">S_Ten</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">Vec</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">S_Ten</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">Vec</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">S_Ten</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">Vec</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">S_Ten</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">Vec</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">S_Ten</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">Vec</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">S_Ten</span></div>

<div class="viewcode-block" id="get_shapeFunc"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.get_shapeFunc.html#ConF3D.Auxiliary_functions.get_shapeFunc">[docs]</a><span class="k">def</span> <span class="nf">get_shapeFunc</span><span class="p">(</span><span class="n">Ansatz_fkt_coeff</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the symbolic representation of the shape functions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Ansatz_fkt_coeff : (number of nodes, r,s,t) nd-array</span>
<span class="sd">        Coefficients of shape functions </span>
<span class="sd">    r : SymPy symbol</span>
<span class="sd">        Natural coordinate r</span>
<span class="sd">    s : SymPy symbol</span>
<span class="sd">        Natural coordinate s</span>
<span class="sd">    t : SymPy symbol</span>
<span class="sd">        Natural coordinate t</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    shapeFunc : (number of nodes, 1) SymPy matrix </span>
<span class="sd">        Symbolic definition of the shape functions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shapeFunc</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ansatz_fkt_coeff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">expr</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ansatz_fkt_coeff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ansatz_fkt_coeff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ansatz_fkt_coeff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
                    <span class="n">expr</span><span class="o">+=</span><span class="n">sy</span><span class="o">.</span><span class="n">nsimplify</span><span class="p">(</span><span class="n">Ansatz_fkt_coeff</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">],</span><span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span><span class="o">*</span><span class="n">r</span><span class="o">**</span><span class="n">x</span><span class="o">*</span><span class="n">s</span><span class="o">**</span><span class="n">y</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="n">z</span>
        <span class="n">shapeFunc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="n">shapeFunc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_jac"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.get_jac.html#ConF3D.Auxiliary_functions.get_jac">[docs]</a><span class="k">def</span> <span class="nf">get_jac</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">,</span><span class="n">points_xyz</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the jacobi matrix symbollically for a element</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shapeFunc : (number of nodes, 1) SymPy matrix </span>
<span class="sd">        Symbolic definition of the shape functions</span>
<span class="sd">    points_xyz : (number of nodes,3)</span>
<span class="sd">        Symbolic definition of the nodal coordinates</span>
<span class="sd">    r : SymPy symbol</span>
<span class="sd">        Natural coordinate r</span>
<span class="sd">    s : SymPy symbol</span>
<span class="sd">        Natural coordinate s</span>
<span class="sd">    t : SymPy symbol</span>
<span class="sd">        Natural coordinate t</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jac : </span>
<span class="sd">        Symbolic definition of the jacobi matrix of an element</span>
<span class="sd">        depending on the natural coordinates r,s,t</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">jac</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shapeFunc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">jac</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="n">sy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">[</span><span class="n">node</span><span class="p">],</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="n">points_xyz</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">jac</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="n">sy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">[</span><span class="n">node</span><span class="p">],</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="n">points_xyz</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">jac</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">+=</span><span class="n">sy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">[</span><span class="n">node</span><span class="p">],</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="n">points_xyz</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">jac</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="n">sy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">[</span><span class="n">node</span><span class="p">],</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">points_xyz</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">jac</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="n">sy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">[</span><span class="n">node</span><span class="p">],</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">points_xyz</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">jac</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">+=</span><span class="n">sy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">[</span><span class="n">node</span><span class="p">],</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">points_xyz</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">jac</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="n">sy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">[</span><span class="n">node</span><span class="p">],</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">points_xyz</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">jac</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="n">sy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">[</span><span class="n">node</span><span class="p">],</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">points_xyz</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">jac</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">+=</span><span class="n">sy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">[</span><span class="n">node</span><span class="p">],</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">points_xyz</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">jac</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_val_at_int_Pkt"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.get_val_at_int_Pkt.html#ConF3D.Auxiliary_functions.get_val_at_int_Pkt">[docs]</a><span class="k">def</span> <span class="nf">get_val_at_int_Pkt</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates a value at the integration point of an element</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shapeFunc : (number of nodes, 1) SymPy matrix or nd-array</span>
<span class="sd">        Symbolic definition of the shape functions</span>
<span class="sd">    value : (number of nodes,3) SymPy matrix or nd-array</span>
<span class="sd">        Nodal value </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    val : (3,) SymPy matrix </span>
<span class="sd">        Value of Element Nodal results inside the element</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shapeFunc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="n">shapeFunc</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">*</span><span class="n">value</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="n">shapeFunc</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">*</span><span class="n">value</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+=</span><span class="n">shapeFunc</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">*</span><span class="n">value</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">val</span><span class="p">)</span></div>

<div class="viewcode-block" id="inversion_and_det_3x3"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.inversion_and_det_3x3.html#ConF3D.Auxiliary_functions.inversion_and_det_3x3">[docs]</a><span class="k">def</span> <span class="nf">inversion_and_det_3x3</span><span class="p">(</span><span class="n">m_in</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverts a symbolic 3x3 matrix and calculates the determinant.</span>
<span class="sd">    This can be also accomplished with SymPy, the use of this function is for performance reasons only.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m_in : (3,3) SymPy matrix</span>
<span class="sd">        Symbolic 3x3 matrix to be inverted</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    minv : (3,3) SymPy matrix</span>
<span class="sd">        Inverted symbolic matrix</span>
<span class="sd">    determinant : SymPy expression</span>
<span class="sd">        Determinant of the matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shape</span><span class="o">=</span><span class="n">m_in</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">m</span><span class="o">=</span><span class="n">m_in</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span>
    
    <span class="n">minv</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">))</span>
    <span class="n">determinant</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
    <span class="n">determinant_inv</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">determinant</span>
    <span class="n">minv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span><span class="o">*</span><span class="n">determinant_inv</span>
    <span class="n">minv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span><span class="o">*</span><span class="n">determinant_inv</span>
    <span class="n">minv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">*</span><span class="n">determinant_inv</span>
    <span class="n">minv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span><span class="o">*</span><span class="n">determinant_inv</span>
    <span class="n">minv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span><span class="o">*</span><span class="n">determinant_inv</span>
    <span class="n">minv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span><span class="o">*</span><span class="n">determinant_inv</span>
    <span class="n">minv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span><span class="o">*</span><span class="n">determinant_inv</span>
    <span class="n">minv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span><span class="o">*</span><span class="n">determinant_inv</span>
    <span class="n">minv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">determinant_inv</span>
    <span class="k">return</span> <span class="n">minv</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">determinant</span></div>

<div class="viewcode-block" id="inversion_and_det_2x2"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.inversion_and_det_2x2.html#ConF3D.Auxiliary_functions.inversion_and_det_2x2">[docs]</a><span class="k">def</span> <span class="nf">inversion_and_det_2x2</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverts a symbolic 2x2 matrix and calculates the determinant.</span>

<span class="sd">    This can be also accomplished with SymPy, the use of this function is for performance reasons only.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : (2,2) SymPy matrix</span>
<span class="sd">        Symbolic 2x2 matrix to be inverted</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    minv : (2,2) SymPy matrix</span>
<span class="sd">        Inverted symbolic matrix</span>
<span class="sd">    determinant : SymPy expression</span>
<span class="sd">        Determinant of the matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">minv</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">))</span>
    <span class="n">determinant</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">determinant_inv</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">determinant</span>
    <span class="n">minv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span>   <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">determinant_inv</span>
    <span class="n">minv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">determinant_inv</span>
    <span class="n">minv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">determinant_inv</span>
    <span class="n">minv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span>   <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">determinant_inv</span>
    <span class="k">return</span> <span class="n">minv</span><span class="p">,</span><span class="n">determinant</span></div>

<div class="viewcode-block" id="get_det_and_inv"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.get_det_and_inv.html#ConF3D.Auxiliary_functions.get_det_and_inv">[docs]</a><span class="k">def</span> <span class="nf">get_det_and_inv</span><span class="p">(</span><span class="n">jac</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverts a symbolic matrix and calculates the determinant.</span>

<span class="sd">    This functions works for 3d-elemnts and plane strain 2d-elements.</span>
<span class="sd">    If the determinant of the 3x3 matrix is zero, the 2d- plane strain case </span>
<span class="sd">    is assumed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    jac : (2 or 3,2 or 3) SymPy matrix</span>
<span class="sd">        Symbolic 3x3 matrix to be inverted</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    inv_jac : (2 or 3,2 or 3) SymPy matrix</span>
<span class="sd">        Inverted symbolic matrix</span>
<span class="sd">    det : SymPy expression</span>
<span class="sd">        Determinant of the matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">det</span><span class="o">=</span><span class="n">jac</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
    
    <span class="n">inv_jac</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">det</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">inv_jac</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">],</span><span class="n">det</span><span class="o">=</span><span class="n">inversion_and_det_2x2</span><span class="p">(</span><span class="n">jac</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inv_jac</span><span class="p">,</span><span class="n">det</span><span class="o">=</span><span class="n">inversion_and_det_3x3</span><span class="p">(</span><span class="n">jac</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">inv_jac</span><span class="p">),</span><span class="n">det</span></div>

<div class="viewcode-block" id="evaluate_rst"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.evaluate_rst.html#ConF3D.Auxiliary_functions.evaluate_rst">[docs]</a><span class="k">def</span> <span class="nf">evaluate_rst</span><span class="p">(</span><span class="n">sym_Mat</span><span class="p">,</span><span class="n">Points</span><span class="p">):</span>
    <span class="n">New_Mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">num_Point</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">subs</span><span class="o">=</span><span class="p">((</span><span class="s2">&quot;r&quot;</span><span class="p">,</span><span class="n">Points</span><span class="p">[</span><span class="n">num_Point</span><span class="p">,</span><span class="mi">0</span><span class="p">]),(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span><span class="n">Points</span><span class="p">[</span><span class="n">num_Point</span><span class="p">,</span><span class="mi">1</span><span class="p">]),(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span><span class="n">Points</span><span class="p">[</span><span class="n">num_Point</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">New_Mat</span><span class="p">[</span><span class="n">num_Point</span><span class="p">]</span><span class="o">=</span><span class="n">sym_Mat</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">New_Mat</span></div>

<div class="viewcode-block" id="calc_dN_rst"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.calc_dN_rst.html#ConF3D.Auxiliary_functions.calc_dN_rst">[docs]</a><span class="k">def</span> <span class="nf">calc_dN_rst</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the derivivative of the shape functions with respect to</span>
<span class="sd">    the natural coordinates r,s,t</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shapeFunc : (number of nodes, 1) SymPy matrix </span>
<span class="sd">        Symbolic definition of the shape functions</span>
<span class="sd">    r : SymPy symbol</span>
<span class="sd">        Natural coordinate r</span>
<span class="sd">    s : SymPy symbol</span>
<span class="sd">        Natural coordinate s</span>
<span class="sd">    t : SymPy symbol</span>
<span class="sd">        Natural coordinate t</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dN_rst : (number of nodes,3) SymPy matrix</span>
<span class="sd">        Derived shape functions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dN_rst</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">shapeFunc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shapeFunc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">dN_rst</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="n">sy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">[</span><span class="n">node</span><span class="p">],</span><span class="n">r</span><span class="p">)</span>
        <span class="n">dN_rst</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="n">sy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">[</span><span class="n">node</span><span class="p">],</span><span class="n">s</span><span class="p">)</span>
        <span class="n">dN_rst</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">+=</span><span class="n">sy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">[</span><span class="n">node</span><span class="p">],</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dN_rst</span></div>

<div class="viewcode-block" id="lambdify_numba"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.lambdify_numba.html#ConF3D.Auxiliary_functions.lambdify_numba">[docs]</a><span class="k">def</span> <span class="nf">lambdify_numba</span><span class="p">(</span><span class="n">args</span><span class="p">,</span><span class="n">arg_names</span><span class="p">,</span><span class="n">expr</span><span class="p">,</span><span class="n">expr_name</span><span class="o">=</span><span class="s2">&quot;_lambdified&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates Numba code for a given symbolic expression. </span>

<span class="sd">    This function is called by gen_Integration_Numba</span>
<span class="sd">    This function isn&#39;t tested and is an alternative to the function which generates C-code.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    args : Tuple(symbolic objects)</span>
<span class="sd">        Tuple of symbolically defined arguments</span>
<span class="sd">    arg_names : Tuple(str,)</span>
<span class="sd">        Tuple of the symbol names</span>
<span class="sd">    expr : SymPy expression</span>
<span class="sd">        Symbolic expression for which the numerical implementation should be generated</span>
<span class="sd">    expr_name : string</span>
<span class="sd">        Name of the generated function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    s : string</span>
<span class="sd">        Numba function as string </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">sympy</span>
    <span class="n">sy</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">fcode</span>
    <span class="kn">from</span> <span class="nn">sympy.printing.pycode</span> <span class="kn">import</span> <span class="n">PythonCodePrinter</span> <span class="k">as</span> <span class="n">Printer</span>
    <span class="n">printer</span> <span class="o">=</span> <span class="n">Printer</span><span class="p">({</span><span class="s1">&#39;fully_qualified_modules&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;inline&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span><span class="s1">&#39;allow_unknown_functions&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
    
    <span class="n">arg_names_str</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arg_names</span><span class="p">)):</span>
        <span class="n">arg_names_str</span><span class="o">+=</span><span class="n">arg_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">arg_names_str</span><span class="o">+=</span><span class="s2">&quot;,&quot;</span>
    
    <span class="c1">###############</span>
    <span class="c1">#generate outputs</span>
    <span class="n">outputs</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="p">)):</span>
            <span class="n">outputs</span><span class="o">+=</span><span class="s2">&quot;,res_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">outputs</span><span class="o">+=</span><span class="s2">&quot;,res_0&quot;</span>
    
    <span class="n">s</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="n">s</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;from numpy import *</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;import numba as nb</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;@nb.njit(fastmath=True,error_model=&#39;numpy&#39;)</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;def &quot;</span><span class="o">+</span><span class="n">expr_name</span><span class="o">+</span><span class="s2">&quot;(&quot;</span><span class="o">+</span><span class="n">arg_names_str</span><span class="o">+</span><span class="n">outputs</span><span class="o">+</span><span class="s2">&quot;):</span><span class="se">\n</span><span class="s2">&quot;</span>
    
    
    <span class="c1">#Expand Matrix args</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)):</span>
        <span class="n">arg</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">ImmutableMatrix</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    &quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot; = &quot;</span> <span class="o">+</span> <span class="n">arg_names</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;[&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;,&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;]</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">)):</span>
                <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    &quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot; = &quot;</span> <span class="o">+</span> <span class="n">arg_names</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;[&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;]</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">arg_names</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
                <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    &quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; = &quot;</span> <span class="o">+</span> <span class="n">arg_names</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    </span><span class="se">\n</span><span class="s2">&quot;</span>
    
    <span class="c1">#Simplify expr</span>
    <span class="n">sub_exprs</span><span class="p">,</span> <span class="n">simplified_rhs</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">cse</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    
    <span class="c1">#Write Subexpressions</span>
    <span class="k">for</span> <span class="n">sub_expr</span> <span class="ow">in</span> <span class="n">sub_exprs</span><span class="p">:</span>
        <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    &quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span><span class="s2">&quot; = &quot;</span><span class="o">+</span><span class="n">printer</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    </span><span class="se">\n</span><span class="s2">&quot;</span>
    
    <span class="c1">#Write rhs_expressions and generate return</span>
    <span class="n">res_counter</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">return_s</span><span class="o">=</span><span class="s2">&quot;    return &quot;</span>
    <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">simplified_rhs</span><span class="p">:</span>
        <span class="c1">#If the expr is a matrix</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">is_Matrix</span><span class="p">:</span>
            <span class="n">rhs_result</span><span class="o">=</span><span class="n">sympy</span><span class="o">.</span><span class="n">MatrixSymbol</span><span class="p">(</span><span class="s1">&#39;rhs_result&#39;</span><span class="p">,</span> <span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    res_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">res_counter</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;[&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;,&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;]&quot;</span><span class="o">+</span><span class="s2">&quot; = &quot;</span><span class="o">+</span>\
                        <span class="n">printer</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    res_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">res_counter</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; = &quot;</span><span class="o">+</span><span class="n">printer</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">return_s</span><span class="o">+=</span><span class="s2">&quot;res_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">res_counter</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>
        <span class="n">res_counter</span><span class="o">+=</span><span class="mi">1</span>
    
    <span class="c1">#Return output</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    </span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="n">return_s</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="gen_Integration_Numba"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.gen_Integration_Numba.html#ConF3D.Auxiliary_functions.gen_Integration_Numba">[docs]</a><span class="k">def</span> <span class="nf">gen_Integration_Numba</span><span class="p">(</span><span class="n">rst</span><span class="p">,</span><span class="n">coord</span><span class="p">,</span><span class="n">Element_U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">SENER</span><span class="p">,</span><span class="n">PENER</span><span class="p">,</span><span class="n">int_points</span><span class="p">,</span><span class="n">weights</span><span class="p">,</span><span class="n">expr</span><span class="p">,</span><span class="n">expr_name</span><span class="o">=</span><span class="s2">&quot;C3D20&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates Numba code for the static implementation of configurational forces at element nodal position.</span>

<span class="sd">    The generation of Numba code is not officially supported by this package, therfore this function is left as an example.</span>
<span class="sd">    This function performs the numeric integration of function values determined at the integration points.</span>
<span class="sd">    The numeric representation at the integration point is generated by lambdify_numba.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rst : (3) SymPy matrix</span>
<span class="sd">        Symbolically defined coordinates</span>
<span class="sd">    coord : (Number of Nodes,3) SymPy matrix</span>
<span class="sd">        Symbolically defined nodal coordinates</span>
<span class="sd">    Element_U : (Number of Nodes,3) SymPy matrix</span>
<span class="sd">        Symbolically defined nodal displacements</span>
<span class="sd">    S : (6,1) or (3,3) SymPy matrix</span>
<span class="sd">        Symbolically defined stress tensor at integration point</span>
<span class="sd">    SENER : SymPy symbol</span>
<span class="sd">        Symbolically defined strain energy at integration point</span>
<span class="sd">    PENER : SymPy symbol</span>
<span class="sd">        Symbolically defined plastic energy at integration point</span>
<span class="sd">    int_points : (Number of integration points,3) nd-array</span>
<span class="sd">        Natural coordinates of the integration point of an element</span>
<span class="sd">    weights : (Number of integration points) nd-array</span>
<span class="sd">        Integration weights</span>
<span class="sd">    expr : SymPy expression</span>
<span class="sd">        Symbolic expression for which the numerical implementation should be generated</span>
<span class="sd">    expr_name : string</span>
<span class="sd">        Name of the generated function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    s : string</span>
<span class="sd">        Numba function as string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="n">s</span><span class="o">+=</span> <span class="n">lambdify_numba</span><span class="p">((</span><span class="n">rst</span><span class="p">,</span><span class="n">coord</span><span class="p">,</span><span class="n">Element_U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">SENER</span><span class="p">,</span><span class="n">PENER</span><span class="p">),(</span><span class="s2">&quot;rst&quot;</span><span class="p">,</span><span class="s2">&quot;coord&quot;</span><span class="p">,</span><span class="s2">&quot;Element_U&quot;</span><span class="p">,</span><span class="s2">&quot;S&quot;</span><span class="p">,</span><span class="s2">&quot;SENER&quot;</span><span class="p">,</span><span class="s2">&quot;PENER&quot;</span><span class="p">),</span><span class="n">expr</span><span class="p">,</span><span class="n">expr_name</span><span class="o">=</span><span class="n">expr_name</span><span class="p">)</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;@nb.njit(fastmath=True,parallel=True,error_model=&#39;numpy&#39;,cache=True)</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;def Integration_&quot;</span><span class="o">+</span><span class="n">expr_name</span><span class="o">+</span><span class="s2">&quot;(Coords,Element_U,S,PENER,SENER):</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    &quot;&quot;&quot;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Inputs:</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        Coords.........Element_Nodal_Coordinates [num_elem,numNodes,3]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        Element_U......Element_Nodal_Displacements [num_elem,numNodes,3]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        S..............Stress at integration points [num_elem,num_int_points,6]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        PENER..........Plastic strain energy [num_elem,num_int_points]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        SENER..........Elastic strain energy [num_elem,num_int_points]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    &quot;&quot;&quot;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="c1">#print constants</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    weights=np.array((&#39;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">s</span><span class="o">+=</span><span class="nb">str</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;,&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;))</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    int_points=np.array(</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">int_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        (&#39;</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">int_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">s</span><span class="o">+=</span><span class="nb">str</span><span class="p">(</span><span class="n">int_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;,&quot;</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">int_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;)&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Conf_Force=np.zeros((Coords.shape[0],Coords.shape[1],3))</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    for i in nb.prange(Coords.shape[0]):</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        res_0=np.empty((Coords.shape[1],3))</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        for j in range(int_points.shape[0]):</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;            res_0=C_Force_&#39;</span><span class="o">+</span><span class="n">expr_name</span><span class="o">+</span><span class="s1">&#39;(int_points[j],Coords[i],Element_U[i],S_vec[i,j],PENER[i,j],SENER[i,j],res_0)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;            for num_node in range(Coords.shape[1]):</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;                for ii in range(3):</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;                    Conf_Force[i,num_node,ii]+=res_0[num_node,ii]*weights[j]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    return Conf_Force</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="gen_C_header"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.gen_C_header.html#ConF3D.Auxiliary_functions.gen_C_header">[docs]</a><span class="k">def</span> <span class="nf">gen_C_header</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates the header for the implemnetation in C.</span>

<span class="sd">    Additionally a function to calculate nodal unique values from </span>
<span class="sd">    element nodal values is generated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    s : string</span>
<span class="sd">        C-header and a function to calculate nodal unique values as string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span><span class="o">=</span><span class="s1">&#39;#ifdef _WIN32</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;#    define Conf_Forces_API __declspec(dllexport)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;#else</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;#    define Conf_Forces_API</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;#endif</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;#include &lt;math.h&gt;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;#include &lt;stdint.h&gt;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;#include &lt;stddef.h&gt;</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;Conf_Forces_API void calc_Nodal_C(size_t num_elem_nodal,double CF_out[][3],double CF[][3],int64_t inverse[]){</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    for (size_t i=0;i&lt;num_elem_nodal;i++){</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        for (size_t j=0;j&lt;3;j++){</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;            CF_out[inverse[i]][j]+=CF[i][j];</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        }</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    }</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;}</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="k">return</span> <span class="n">s</span></div>
    
<div class="viewcode-block" id="lambdify_C"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.lambdify_C.html#ConF3D.Auxiliary_functions.lambdify_C">[docs]</a><span class="k">def</span> <span class="nf">lambdify_C</span><span class="p">(</span><span class="n">args</span><span class="p">,</span><span class="n">arg_names</span><span class="p">,</span><span class="n">expr</span><span class="p">,</span><span class="n">expr_name</span><span class="o">=</span><span class="s2">&quot;_lambdified&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates C99 code for a given symbolic expression.</span>

<span class="sd">    This function is called by gen_Integration_C_static or gen_Integration_C_dynamic. In this package this function is used to </span>
<span class="sd">    generate the numeric representation of configurational forces at the integration point, or more specifically the inner part of the integral.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    args : Tuple(symbolic objects)</span>
<span class="sd">        Tuple of symbolically defined arguments</span>
<span class="sd">    arg_names : Tuple(str,)</span>
<span class="sd">        Tuple of the symbol names</span>
<span class="sd">    expr : SymPy expression</span>
<span class="sd">        Symbolic expression for which the numerical implementation should be generated</span>
<span class="sd">    expr_name : string</span>
<span class="sd">        Name of the generated function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    s : string</span>
<span class="sd">        C-function as string </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="kn">import</span> <span class="nn">sympy</span>
    <span class="kn">from</span> <span class="nn">sympy.printing.ccode</span> <span class="kn">import</span> <span class="n">C99CodePrinter</span>  <span class="k">as</span> <span class="n">Printer</span>
    <span class="kn">from</span> <span class="nn">sympy.codegen.rewriting</span> <span class="kn">import</span> <span class="n">create_expand_pow_optimization</span>
    <span class="n">printer</span> <span class="o">=</span> <span class="n">Printer</span><span class="p">()</span>
    <span class="n">expand_opt</span> <span class="o">=</span> <span class="n">create_expand_pow_optimization</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="n">arg_names_str</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arg_names</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">ImmutableMatrix</span><span class="p">,</span><span class="n">sympy</span><span class="o">.</span><span class="n">MatrixSymbol</span><span class="p">,</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">arg_names_str</span><span class="o">+=</span><span class="s2">&quot;double *&quot;</span><span class="o">+</span><span class="n">arg_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arg_names_str</span><span class="o">+=</span><span class="s2">&quot;double &quot;</span><span class="o">+</span><span class="n">arg_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">arg_names_str</span><span class="o">+=</span><span class="s2">&quot;,&quot;</span>
    
    <span class="c1">###############</span>
    <span class="c1">#generate outputs</span>
    <span class="n">outputs</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="p">)):</span>
            <span class="n">outputs</span><span class="o">+=</span><span class="s2">&quot;,double *res_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">outputs</span><span class="o">+=</span><span class="s2">&quot;,double *res_0&quot;</span>
    
    <span class="n">s</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="n">s</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;void &quot;</span><span class="o">+</span><span class="n">expr_name</span><span class="o">+</span><span class="s2">&quot;(&quot;</span><span class="o">+</span><span class="n">arg_names_str</span><span class="o">+</span><span class="n">outputs</span><span class="o">+</span><span class="s2">&quot;){</span><span class="se">\n</span><span class="s2">&quot;</span>
    
    
    <span class="c1">#Expand Matrix args</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)):</span>
        <span class="n">arg</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">ImmutableMatrix</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">ind</span><span class="o">=</span><span class="n">i</span><span class="o">*</span><span class="n">arg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">j</span>
                    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    double &quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot; = &quot;</span> <span class="o">+</span> <span class="n">arg_names</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;[&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;];</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">)):</span>
                <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    double &quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot; = &quot;</span> <span class="o">+</span> <span class="n">arg_names</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;[&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;];</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">arg_names</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
                <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    double *&quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; = &quot;</span> <span class="o">+</span> <span class="n">arg_names</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;;</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    </span><span class="se">\n</span><span class="s2">&quot;</span>
    
    <span class="c1">#Simplify expr</span>
    <span class="n">sub_exprs</span><span class="p">,</span> <span class="n">simplified_rhs</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">cse</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
    
    <span class="c1">#Write Subexpressions</span>
    <span class="k">for</span> <span class="n">sub_expr</span> <span class="ow">in</span> <span class="n">sub_exprs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">,</span> <span class="n">sympy</span><span class="o">.</span><span class="n">ImmutableMatrix</span><span class="p">,</span><span class="n">sympy</span><span class="o">.</span><span class="n">MatrixSymbol</span><span class="p">,</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    double *&quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span><span class="s2">&quot; = &quot;</span><span class="o">+</span><span class="n">printer</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">expand_opt</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span><span class="s2">&quot;;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    double &quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span><span class="s2">&quot; = &quot;</span><span class="o">+</span><span class="n">printer</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">expand_opt</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span><span class="s2">&quot;;</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    </span><span class="se">\n</span><span class="s2">&quot;</span>
    
    <span class="c1">#Write rhs_expressions and generate return</span>
    <span class="n">res_counter</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">return_s</span><span class="o">=</span><span class="s2">&quot;    return &quot;</span>
    <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">simplified_rhs</span><span class="p">:</span>
        <span class="c1">#If the expr is a matrix</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">is_Matrix</span><span class="p">:</span>
            <span class="n">rhs_result</span><span class="o">=</span><span class="n">sympy</span><span class="o">.</span><span class="n">MatrixSymbol</span><span class="p">(</span><span class="s1">&#39;rhs_result&#39;</span><span class="p">,</span> <span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">ind</span><span class="o">=</span><span class="n">i</span><span class="o">*</span><span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">j</span>
                    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    res_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">res_counter</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;[&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;]&quot;</span><span class="o">+</span><span class="s2">&quot; = &quot;</span><span class="o">+</span>\
                        <span class="n">printer</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span><span class="s2">&quot;;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    res_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">res_counter</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; = &quot;</span><span class="o">+</span><span class="n">printer</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span> <span class="o">+</span><span class="s2">&quot;;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">return_s</span><span class="o">+=</span><span class="s2">&quot;res_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">res_counter</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>
        <span class="n">res_counter</span><span class="o">+=</span><span class="mi">1</span>
    
    <span class="c1">#Return output</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span>
    
    <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="gen_Integration_C_dyn"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.gen_Integration_C_dyn.html#ConF3D.Auxiliary_functions.gen_Integration_C_dyn">[docs]</a><span class="k">def</span> <span class="nf">gen_Integration_C_dyn</span><span class="p">(</span><span class="n">rst</span><span class="p">,</span><span class="n">coord</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">Element_U</span><span class="p">,</span><span class="n">Element_V</span><span class="p">,</span><span class="n">Element_A</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">PENER</span><span class="p">,</span><span class="n">SENER</span><span class="p">,</span><span class="n">int_points</span><span class="p">,</span><span class="n">weights</span><span class="p">,</span><span class="n">expr</span><span class="p">,</span><span class="n">expr_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates C99 code for the dynamic implementation of configurational forces at element nodal position.</span>

<span class="sd">    This function is called by :func:`gen_Configurational_Forces_Dynamic` and performs the numeric integration of</span>
<span class="sd">    function values determined at the integration points.</span>
<span class="sd">    Also have a look at this function too see how rst, coord, rho, Element_U, Element_V, Element_A ,S ,SENER ,PENER are defined.</span>
<span class="sd">    The numeric representation at the integration point is generated by :func:`lambdify_C`.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rst : (3) SymPy matrix</span>
<span class="sd">        Symbolically defined coordinates</span>
<span class="sd">    coord : (Number of Nodes,3) SymPy matrix</span>
<span class="sd">        Symbolically defined nodal coordinates</span>
<span class="sd">    rho : SymPy symbol</span>
<span class="sd">        Symbolically defined material density</span>
<span class="sd">    Element_U : (Number of Nodes,3) SymPy matrix</span>
<span class="sd">        Symbolically defined nodal displacements</span>
<span class="sd">    Element_V : (Number of Nodes,3) SymPy matrix</span>
<span class="sd">        Symbolically defined nodal velocity</span>
<span class="sd">    Element_A : (Number of Nodes,3) SymPy matrix</span>
<span class="sd">        Symbolically defined nodal acceleration</span>
<span class="sd">    S : (6,1) or (3,3) SymPy matrix</span>
<span class="sd">        Symbolically defined stress tensor at integration point</span>
<span class="sd">    SENER : SymPy symbol</span>
<span class="sd">        Symbolically defined strain energy at integration point</span>
<span class="sd">    int_points : (Number of integration points,3) nd-array</span>
<span class="sd">        Natural coordinates of the integration point of an element</span>
<span class="sd">    weights : (Number of integration points) nd-array</span>
<span class="sd">        Integration weights</span>
<span class="sd">    expr : SymPy expression</span>
<span class="sd">        Symbolic expression for which the numerical implementation should be generated</span>
<span class="sd">    expr_name : string</span>
<span class="sd">        Name of the generated function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    s : string</span>
<span class="sd">        C-function as string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numNodes</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">num_int_points</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">int_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">s</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="n">s</span><span class="o">+=</span> <span class="n">lambdify_C</span><span class="p">((</span><span class="n">rst</span><span class="p">,</span><span class="n">coord</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">Element_U</span><span class="p">,</span><span class="n">Element_V</span><span class="p">,</span><span class="n">Element_A</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">PENER</span><span class="p">,</span><span class="n">SENER</span><span class="p">),(</span><span class="s2">&quot;rst&quot;</span><span class="p">,</span><span class="s2">&quot;coord&quot;</span><span class="p">,</span><span class="s2">&quot;rho&quot;</span><span class="p">,</span><span class="s2">&quot;Element_U&quot;</span><span class="p">,</span><span class="s2">&quot;Element_V&quot;</span><span class="p">,</span><span class="s2">&quot;Element_A&quot;</span><span class="p">,</span><span class="s2">&quot;S&quot;</span><span class="p">,</span><span class="s2">&quot;PENER&quot;</span><span class="p">,</span><span class="s2">&quot;SENER&quot;</span><span class="p">),</span><span class="n">expr</span><span class="p">,</span><span class="n">expr_name</span><span class="o">=</span><span class="n">expr_name</span><span class="p">)</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;Conf_Forces_API void Integration_&quot;</span><span class="o">+</span><span class="n">expr_name</span><span class="o">+</span><span class="s2">&quot;(size_t num_elem,double Coords[][&quot;</span><span class="o">+</span><span class="n">numNodes</span><span class="o">+</span><span class="s2">&quot;][3],double *rho,&quot;</span><span class="o">+</span>\
        <span class="s2">&quot;double Element_U[][&quot;</span><span class="o">+</span><span class="n">numNodes</span><span class="o">+</span><span class="s2">&quot;][3],double Element_V[][&quot;</span><span class="o">+</span><span class="n">numNodes</span><span class="o">+</span><span class="s2">&quot;][3],double Element_A[][&quot;</span><span class="o">+</span><span class="n">numNodes</span><span class="o">+</span><span class="s2">&quot;][3],double S[][&quot;</span><span class="o">+</span><span class="n">num_int_points</span><span class="o">+</span><span class="s2">&quot;][6],</span><span class="se">\n</span><span class="s2">    &quot;</span><span class="o">+</span>\
        <span class="s2">&quot;double PENER[][&quot;</span><span class="o">+</span><span class="n">num_int_points</span><span class="o">+</span><span class="s2">&quot;],double SENER[][&quot;</span><span class="o">+</span><span class="n">num_int_points</span><span class="o">+</span><span class="s2">&quot;],double Conf_Force[][&quot;</span><span class="o">+</span><span class="n">numNodes</span><span class="o">+</span><span class="s2">&quot;][3]){</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    </span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    //Inputs:</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    //    Coords.........Element_Nodal_Coordinates  [num_elem][numNodes,3]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    //    Element_U......Element_Nodal_Displacements[num_elem][numNodes,3]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    //    Element_V......Element_Nodal_Velocity     [num_elem][numNodes,3]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    //    Element_A......Element_Nodal_Acceleration [num_elem][numNodes,3]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    //    S..............Stress at integration points [num_elem][num_int_points,6]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    //    PENER..........Plastic strain energy [num_elem][num_int_points]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    //    SENER..........Elastic strain energy [num_elem][num_int_points]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    //    </span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="c1">#print constants</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    double weights[&#39;</span><span class="o">+</span><span class="n">num_int_points</span><span class="o">+</span><span class="s1">&#39;]={&#39;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">s</span><span class="o">+=</span><span class="nb">str</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;,&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;};</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    double int_points[&#39;</span><span class="o">+</span><span class="n">num_int_points</span><span class="o">+</span><span class="s1">&#39;][3]={</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">int_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        {&#39;</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">int_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">s</span><span class="o">+=</span><span class="nb">str</span><span class="p">(</span><span class="n">int_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;,&quot;</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">int_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;}&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;},</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;};</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    #pragma omp parallel for</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    for (size_t i=0;i&lt;num_elem;i++){</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        double TMP[&#39;</span><span class="o">+</span><span class="n">numNodes</span><span class="o">+</span><span class="s1">&#39;][3];</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        for (size_t j=0;j&lt;&#39;</span><span class="o">+</span><span class="n">num_int_points</span><span class="o">+</span><span class="s1">&#39;;j++){</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;            &#39;</span><span class="o">+</span><span class="n">expr_name</span><span class="o">+</span><span class="s1">&#39;((double*) int_points[j],(double*) Coords[i],rho[i],(double*) Element_U[i],(double*) Element_V[i],(double*) Element_A[i],(double*) S[i][j],PENER[i][j],SENER[i][j],(double*) TMP);</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;            for (size_t num_node=0;num_node&lt;&#39;</span><span class="o">+</span><span class="n">numNodes</span><span class="o">+</span><span class="s1">&#39;;num_node++){</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;                for (size_t ii=0;ii&lt;3;ii++){</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;                    Conf_Force[i][num_node][ii]+=TMP[num_node][ii]*weights[j];</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;                }</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;            }</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        }</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    }</span><span class="se">\n</span><span class="s1">&#39;</span> 
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;}</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="gen_Integration_C_static"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.gen_Integration_C_static.html#ConF3D.Auxiliary_functions.gen_Integration_C_static">[docs]</a><span class="k">def</span> <span class="nf">gen_Integration_C_static</span><span class="p">(</span><span class="n">rst</span><span class="p">,</span><span class="n">coord</span><span class="p">,</span><span class="n">Element_U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">PENER</span><span class="p">,</span><span class="n">SENER</span><span class="p">,</span><span class="n">int_points</span><span class="p">,</span><span class="n">weights</span><span class="p">,</span><span class="n">expr</span><span class="p">,</span><span class="n">expr_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates C99 code for the static implementation of configurational forces at element nodal position.</span>

<span class="sd">    This function is called by :func:`gen_Configurational_Forces_Static` and performs the numeric integration of</span>
<span class="sd">    function values determined at the integration points.</span>
<span class="sd">    Have a look at this function too see how rst, coord, Element_U, S, SENER, PENER are defined.</span>
<span class="sd">    The numeric representation at the integration point is generated by :func:`lambdify_C`.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rst : (3) SymPy matrix</span>
<span class="sd">        Symbolically defined coordinates</span>
<span class="sd">    coord : (Number of Nodes,3) SymPy matrix</span>
<span class="sd">        Symbolically defined nodal coordinates</span>
<span class="sd">    Element_U : (Number of Nodes,3) SymPy matrix</span>
<span class="sd">        Symbolically defined nodal displacements</span>
<span class="sd">    S : (6,1) or (3,3) SymPy matrix</span>
<span class="sd">        Symbolically defined stress tensor at integration point</span>
<span class="sd">    SENER : SymPy symbol</span>
<span class="sd">        Symbolically defined strain energy at integration point</span>
<span class="sd">    PENER : SymPy symbol</span>
<span class="sd">        Symbolically defined plastic energy at integration point</span>
<span class="sd">    int_points : (Number of integration points,3) nd-array</span>
<span class="sd">        Natural coordinates of the integration point of an element</span>
<span class="sd">    weights : (Number of integration points) nd-array</span>
<span class="sd">        Integration weights</span>
<span class="sd">    expr : SymPy expression</span>
<span class="sd">        Symbolic expression for which the numerical implementation should be generated</span>
<span class="sd">    expr_name : string</span>
<span class="sd">        Name of the generated function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    s : string</span>
<span class="sd">        C-function as string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numNodes</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">num_int_points</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">int_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">s</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="n">s</span><span class="o">+=</span> <span class="n">lambdify_C</span><span class="p">((</span><span class="n">rst</span><span class="p">,</span><span class="n">coord</span><span class="p">,</span><span class="n">Element_U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">PENER</span><span class="p">,</span><span class="n">SENER</span><span class="p">),(</span><span class="s2">&quot;rst&quot;</span><span class="p">,</span><span class="s2">&quot;coord&quot;</span><span class="p">,</span><span class="s2">&quot;Element_U&quot;</span><span class="p">,</span><span class="s2">&quot;S&quot;</span><span class="p">,</span><span class="s2">&quot;PENER&quot;</span><span class="p">,</span><span class="s2">&quot;SENER&quot;</span><span class="p">),</span><span class="n">expr</span><span class="p">,</span><span class="n">expr_name</span><span class="o">=</span><span class="n">expr_name</span><span class="p">)</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;Conf_Forces_API void Integration_&quot;</span><span class="o">+</span><span class="n">expr_name</span><span class="o">+</span><span class="s2">&quot;(size_t num_elem,double Coords[][&quot;</span><span class="o">+</span><span class="n">numNodes</span><span class="o">+</span><span class="s2">&quot;][3],&quot;</span><span class="o">+</span>\
        <span class="s2">&quot;double Element_U[][&quot;</span><span class="o">+</span><span class="n">numNodes</span><span class="o">+</span><span class="s2">&quot;][3],double S[][&quot;</span><span class="o">+</span><span class="n">num_int_points</span><span class="o">+</span><span class="s2">&quot;][6],</span><span class="se">\n</span><span class="s2">    &quot;</span><span class="o">+</span>\
        <span class="s2">&quot;double PENER[][&quot;</span><span class="o">+</span><span class="n">num_int_points</span><span class="o">+</span><span class="s2">&quot;],double SENER[][&quot;</span><span class="o">+</span><span class="n">num_int_points</span><span class="o">+</span><span class="s2">&quot;],double Conf_Force[][&quot;</span><span class="o">+</span><span class="n">numNodes</span><span class="o">+</span><span class="s2">&quot;][3]){</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    </span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    //Inputs:</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    //    Coords.........Element_Nodal_Coordinates [num_elem][numNodes,3]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    //    Element_U......Element_Nodal_Displacements [num_elem][numNodes,3]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    //    S..............Stress at integration points [num_elem][num_int_points,6]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    //    PENER..........Plastic strain energy [num_elem][num_int_points]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    //    SENER..........Elastic strain energy [num_elem][num_int_points]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    //    </span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="c1">#print constants</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    double weights[&#39;</span><span class="o">+</span><span class="n">num_int_points</span><span class="o">+</span><span class="s1">&#39;]={&#39;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">s</span><span class="o">+=</span><span class="nb">str</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;,&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;};</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    double int_points[&#39;</span><span class="o">+</span><span class="n">num_int_points</span><span class="o">+</span><span class="s1">&#39;][3]={</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">int_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        {&#39;</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">int_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">s</span><span class="o">+=</span><span class="nb">str</span><span class="p">(</span><span class="n">int_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;,&quot;</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">int_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;}&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;},</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;};</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    #pragma omp parallel for</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    for (size_t i=0;i&lt;num_elem;i++){</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        double TMP[&#39;</span><span class="o">+</span><span class="n">numNodes</span><span class="o">+</span><span class="s1">&#39;][3];</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        for (size_t j=0;j&lt;&#39;</span><span class="o">+</span><span class="n">num_int_points</span><span class="o">+</span><span class="s1">&#39;;j++){</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;            &#39;</span><span class="o">+</span><span class="n">expr_name</span><span class="o">+</span><span class="s1">&#39;((double*) int_points[j],(double*) Coords[i],(double*) Element_U[i],(double*) S[i][j],PENER[i][j],SENER[i][j],(double*) TMP);</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;            for (size_t num_node=0;num_node&lt;&#39;</span><span class="o">+</span><span class="n">numNodes</span><span class="o">+</span><span class="s1">&#39;;num_node++){</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;                for (size_t ii=0;ii&lt;3;ii++){</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;                    Conf_Force[i][num_node][ii]+=TMP[num_node][ii]*weights[j];</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;                }</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;            }</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        }</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    }</span><span class="se">\n</span><span class="s1">&#39;</span> 
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;}</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="gen_Python_Wrapper_Header"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.gen_Python_Wrapper_Header.html#ConF3D.Auxiliary_functions.gen_Python_Wrapper_Header">[docs]</a><span class="k">def</span> <span class="nf">gen_Python_Wrapper_Header</span><span class="p">(</span><span class="n">lib_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates the header of the Python wrapper used to call the C-implementations from Python.</span>

<span class="sd">    This function also defines the function calc_Nodal, which is used to calculate unique nodal results</span>
<span class="sd">    of configurational forces calculated on element nodal position.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lib_name : string</span>
<span class="sd">        Name of the compiled library</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    s : string</span>
<span class="sd">        Python code as string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span><span class="o">=</span> <span class="s1">&#39;import numpy as np</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;import ctypes</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;import os</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;# Determine Operating System</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;if os.name == &#39;nt&#39;:</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    lib = ctypes.cdll.LoadLibrary(&quot;&#39;</span><span class="o">+</span><span class="n">lib_name</span><span class="o">+</span><span class="s1">&#39;.dll&quot;)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;else:</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    lib = ctypes.cdll.LoadLibrary(&quot;./&#39;</span><span class="o">+</span><span class="n">lib_name</span><span class="o">+</span><span class="s1">&#39;.so&quot;)</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;def calc_Nodal(Element_Connectivity,CF):</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    &quot;&quot;&quot;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Input:</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Element_Connectivity.......List of np.arrays or np.array</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    CF_in......................List of np.arrays or np.array</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Output:</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Node_labels................Array of unique Nodelabels where CF is calcualted</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    CF_out.....................Array of unique Nodal Configurational Forces [num_nodes,3]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    &quot;&quot;&quot;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    if not isinstance(Element_Connectivity,list):</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        Element_Connectivity=[Element_Connectivity]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        CF=[CF]</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Element_Connectivity=np.concatenate([elem_con.reshape(-1) for elem_con in Element_Connectivity])</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    CF=np.concatenate([cf.reshape(-1,3) for cf in CF])</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    assert Element_Connectivity.shape[0]==CF.shape[0]</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Node_labels,inverse=np.unique(Element_Connectivity,return_inverse=True)</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    CF=np.ascontiguousarray(CF,dtype=np.float64)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    inverse=np.ascontiguousarray(inverse,dtype=np.int64)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    CF_out=np.zeros((Node_labels.shape[0],3),dtype=np.float64)</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    num_elem_nodal=ctypes.c_size_t(inverse.shape[0])</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    CF_out_p=CF_out.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    CF_p=CF.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    inverse_p=inverse.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    lib.calc_Nodal_C(num_elem_nodal,CF_out_p,CF_p,inverse_p)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    return Node_labels,CF_out</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="k">return</span> <span class="n">s</span></div>
        

<div class="viewcode-block" id="gen_Python_Wrapper_static"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.gen_Python_Wrapper_static.html#ConF3D.Auxiliary_functions.gen_Python_Wrapper_static">[docs]</a><span class="k">def</span> <span class="nf">gen_Python_Wrapper_static</span><span class="p">(</span><span class="n">expr_name</span><span class="p">,</span><span class="n">numNodes</span><span class="p">,</span><span class="n">num_int_points</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates the Python wrapper used to call the static configurational force implementation from Python.</span>

<span class="sd">    This wrapper also includes basic checks for array types and datatypes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    expr_name : string</span>
<span class="sd">        Name of the generated function.</span>
<span class="sd">    </span>
<span class="sd">    numNodes : int</span>
<span class="sd">        Number of nodes</span>
<span class="sd">    num_int_points : int</span>
<span class="sd">        Number of integration points</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    s : string</span>
<span class="sd">        Python code as string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span><span class="o">=</span><span class="s2">&quot;def calc_Conf_Force_&quot;</span> <span class="o">+</span> <span class="n">expr_name</span> <span class="o">+</span><span class="s2">&quot;(Coords,Element_U,S_vec,PENER,SENER,method=&#39;mbf&#39;):</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    &quot;&quot;&quot;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Inputs:</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        Coords.........Element_Nodal_Coordinates [num_elem,numNodes,3]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        Element_U......Element_Nodal_Displacements [num_elem,numNodes,3]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        S_vec......... Stress at integration points [num_elem,num_int_points,6]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        PENER..........Plastic strain energy [num_elem,num_int_points]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        SENER..........Elastic strain energy [num_elem,num_int_points]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    &quot;&quot;&quot;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    #This is for safety, the C code will crash without warnings on wrong inputs...</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    ################################################</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    num_elem=Coords.shape[0]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    numNodes=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">numNodes</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    num_int_points=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">num_int_points</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    assert Coords.shape==(num_elem,numNodes,3)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    assert Element_U.shape==(num_elem,numNodes,3)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    assert S_vec.shape==(num_elem,num_int_points,6)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    assert PENER.shape==(num_elem,num_int_points)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    assert SENER.shape==(num_elem,num_int_points)</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    #Ensure that all arrays are c contiguous</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Coords=np.ascontiguousarray(Coords,dtype=np.float64)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Element_U=np.ascontiguousarray(Element_U,dtype=np.float64)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    S_vec=np.ascontiguousarray(S_vec,dtype=np.float64)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    PENER=np.ascontiguousarray(PENER,dtype=np.float64)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    SENER=np.ascontiguousarray(SENER,dtype=np.float64)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    ################################################</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    num_elem_=ctypes.c_size_t(Coords.shape[0])</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Coords_p=Coords.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Element_U_p=Element_U.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    S_vec_p=S_vec.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    PENER_p=PENER.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    SENER_p=SENER.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Conf_Force=np.zeros((Coords.shape[0],Coords.shape[1],3))</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Conf_Force_p=Conf_Force.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    if method==&#39;mbf&#39;:</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        lib.Integration_&#39;</span><span class="o">+</span><span class="n">expr_name</span><span class="o">+</span><span class="s1">&#39;_mbf(num_elem_,Coords_p,Element_U_p,S_vec_p,PENER_p,SENER_p,Conf_Force_p)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s2">&quot;    elif method==&#39;dbf&#39;:</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        lib.Integration_&#39;</span><span class="o">+</span><span class="n">expr_name</span><span class="o">+</span><span class="s1">&#39;_dbf(num_elem_,Coords_p,Element_U_p,S_vec_p,PENER_p,SENER_p,Conf_Force_p)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    else:</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        print(&quot;Method not found!&quot;)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    return Conf_Force</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="gen_Python_Wrapper_dynamic"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.gen_Python_Wrapper_dynamic.html#ConF3D.Auxiliary_functions.gen_Python_Wrapper_dynamic">[docs]</a><span class="k">def</span> <span class="nf">gen_Python_Wrapper_dynamic</span><span class="p">(</span><span class="n">expr_name</span><span class="p">,</span><span class="n">numNodes</span><span class="p">,</span><span class="n">num_int_points</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates the Python wrapper used to call the dynamic configurational force implementation from Python.</span>

<span class="sd">    This wrapper also includes basic checks for array types and datatypes.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    expr_name : string</span>
<span class="sd">        Name of the generated function.</span>
<span class="sd">    </span>
<span class="sd">    numNodes : int</span>
<span class="sd">        Number of nodes</span>
<span class="sd">    num_int_points : int</span>
<span class="sd">        Number of integration points</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    s : string</span>
<span class="sd">        Python code as string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span><span class="o">=</span><span class="s2">&quot;def calc_Conf_Force_&quot;</span> <span class="o">+</span> <span class="n">expr_name</span> <span class="o">+</span> <span class="s2">&quot;(Coords,rho,Element_U,Element_V,Element_A,S_vec,PENER,SENER):</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    &quot;&quot;&quot;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Inputs:</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        Coords.........Element_Nodal_Coordinates    [num_elem,numNodesPerElem,3]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        rho............Density                      [num_elem]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        Element_U......Element_Nodal_Displacements  [num_elem,numNodesPerElem,3]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        Element_V......Element_Velocity             [num_elem,numNodesPerElem,3]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        Element_A......Element_Acceleration         [num_elem,numNodesPerElem,3]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        S_vec......... Stress at integration points [num_elem,num_int_points,6]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        PENER..........Plastic strain energy        [num_elem,num_int_points]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;        SENER..........Elastic strain energy        [num_elem,num_int_points]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    &quot;&quot;&quot;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    #This is for safety, the C code will crash without warnings on wrong inputs...</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    ################################################</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    num_elem=Coords.shape[0]</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    numNodes=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">numNodes</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    num_int_points=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">num_int_points</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    assert Coords.shape==(num_elem,numNodes,3)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    assert rho.shape==(num_elem,)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    assert Element_U.shape==(num_elem,numNodes,3)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    assert Element_V.shape==(num_elem,numNodes,3)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    assert Element_A.shape==(num_elem,numNodes,3)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    assert S_vec.shape==(num_elem,num_int_points,6)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    assert PENER.shape==(num_elem,num_int_points)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    assert SENER.shape==(num_elem,num_int_points)</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    #Ensure that all arrays are c contiguous</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Coords=np.ascontiguousarray(Coords,dtype=np.float64)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    rho=np.ascontiguousarray(rho,dtype=np.float64)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Element_U=np.ascontiguousarray(Element_U,dtype=np.float64)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Element_V=np.ascontiguousarray(Element_V,dtype=np.float64)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Element_A=np.ascontiguousarray(Element_A,dtype=np.float64)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    S_vec=np.ascontiguousarray(S_vec,dtype=np.float64)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    PENER=np.ascontiguousarray(PENER,dtype=np.float64)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    SENER=np.ascontiguousarray(SENER,dtype=np.float64)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    ################################################</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    num_elem_=ctypes.c_size_t(Coords.shape[0])</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Coords_p=Coords.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    rho_p   =rho.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Element_U_p=Element_U.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Element_V_p=Element_V.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Element_A_p=Element_A.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    S_vec_p=S_vec.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    PENER_p=PENER.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    SENER_p=SENER.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Conf_Force=np.zeros((Coords.shape[0],Coords.shape[1],3))</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    Conf_Force_p=Conf_Force.ctypes.data_as(ctypes.c_void_p)</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    lib.Integration_&#39;</span><span class="o">+</span><span class="n">expr_name</span><span class="o">+</span><span class="s1">&#39;(num_elem_,Coords_p,rho_p,Element_U_p,Element_V_p,Element_A_p,S_vec_p,PENER_p,SENER_p,Conf_Force_p)</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">s</span><span class="o">+=</span><span class="s1">&#39;    return Conf_Force</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="k">return</span> <span class="n">s</span></div>

<span class="c1">####### Static Impementation #################################</span>
<div class="viewcode-block" id="gen_Configurational_Forces_Static"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.gen_Configurational_Forces_Static.html#ConF3D.Auxiliary_functions.gen_Configurational_Forces_Static">[docs]</a><span class="k">def</span> <span class="nf">gen_Configurational_Forces_Static</span><span class="p">(</span><span class="n">poly_power</span><span class="p">,</span><span class="n">bild_points</span><span class="p">,</span><span class="n">int_points</span><span class="p">,</span><span class="n">int_weights</span><span class="p">,</span><span class="n">typ</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;mbf&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates the static configurational force implementation.</span>
<span class="sd">    This is a entry function and uses functions defined above to generate the numerical implementation </span>
<span class="sd">    of configurational forces for the static and elasto-plastic case.</span>
<span class="sd">    All Inputs are defined in ele_def.py</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    poly_power : (at least number of nodes,3) nd-array</span>
<span class="sd">        Polynomial coefficents of shape functions in 3 dimensional space</span>
<span class="sd">    bild_points : (number of nodes,3) nd-array</span>
<span class="sd">        Natural coordinates of nodes</span>
<span class="sd">    int_points : (number of points, 3) nd-array</span>
<span class="sd">        Polynomial coefficents of shape functions in 3 dimensional space</span>
<span class="sd">    int_weights : (number of points) nd-array</span>
<span class="sd">        Integration weights</span>
<span class="sd">    typ : str</span>
<span class="sd">        Elementtype</span>
<span class="sd">    method : str (mbf/dbf)</span>
<span class="sd">        Motion based or displacement based formulation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    s : string</span>
<span class="sd">        Python code as string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#generate shape functions</span>
    <span class="n">shapeFuncCoef_bild</span><span class="p">,</span><span class="n">shapeFuncCoef_int</span><span class="p">,</span><span class="n">shapeFuncCoef_bild_diff</span><span class="p">,</span><span class="n">shapeFuncCoef_int_diff</span><span class="o">=</span>\
        <span class="n">generate_shape_func_coeff</span><span class="p">(</span><span class="n">bild_points</span><span class="p">,</span><span class="n">int_points</span><span class="p">,</span><span class="n">poly_power</span><span class="p">)</span>

    <span class="c1">#Generate some symbols</span>
    <span class="n">num_nodes</span>   <span class="o">=</span><span class="n">shapeFuncCoef_bild</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">num_int_points</span> <span class="o">=</span><span class="n">int_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">sy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;r s t&quot;</span><span class="p">)</span>
    <span class="n">rst</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
    <span class="n">coord</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">MatrixSymbol</span><span class="p">(</span><span class="s1">&#39;coord&#39;</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">Element_U</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">MatrixSymbol</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">SENER</span><span class="p">,</span><span class="n">PENER</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;SENER PENER&quot;</span><span class="p">)</span>
    <span class="n">S_Ten</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;S11 S22 S33 S12 S13 S23&quot;</span><span class="p">)</span>

    <span class="c1">#Generate Shape functions</span>
    <span class="n">shapeFunc</span><span class="o">=</span><span class="n">get_shapeFunc</span><span class="p">(</span><span class="n">shapeFuncCoef_bild</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>

    <span class="c1">#Calculate Jacobi matrix</span>
    <span class="n">jac</span><span class="o">=</span><span class="n">get_jac</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">,</span><span class="n">coord</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>

    <span class="c1">#Calculate inverse Jacobi matrix</span>
    <span class="n">jac_inv</span><span class="p">,</span><span class="n">jacobi_det</span><span class="o">=</span><span class="n">get_det_and_inv</span><span class="p">(</span><span class="n">jac</span><span class="p">)</span>

    <span class="c1">#calculate du/DX</span>
    <span class="n">Jacobi_Element_U</span><span class="o">=</span><span class="n">get_jac</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">,</span><span class="n">Element_U</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
    <span class="n">dU_dx</span><span class="o">=</span><span class="p">(</span><span class="n">jac_inv</span><span class="o">*</span><span class="n">Jacobi_Element_U</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1">#Calculate deformation gradient</span>
    <span class="n">Def_grad</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">+</span><span class="n">dU_dx</span>

    <span class="c1">#Calculate dN_dxyz </span>
    <span class="n">dN_rst</span><span class="o">=</span><span class="n">calc_dN_rst</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
    <span class="n">dN_dxyz</span><span class="o">=</span><span class="n">dN_rst</span><span class="o">*</span><span class="n">jac_inv</span><span class="o">.</span><span class="n">T</span>

    <span class="c1">#calculate 1st Piola Kirchhoff stress</span>
    <span class="n">S</span><span class="o">=</span><span class="n">gen_2D_Ten_from_vec</span><span class="p">(</span><span class="n">S_Ten</span><span class="p">)</span>
    <span class="n">Def_grad_inv</span><span class="p">,</span><span class="n">Def_grad_det</span><span class="o">=</span><span class="n">get_det_and_inv</span><span class="p">(</span><span class="n">Def_grad</span><span class="p">)</span>
    <span class="n">Piola_1</span><span class="o">=</span> <span class="n">Def_grad_det</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">Def_grad_inv</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1">#Calculate Configurational stress</span>
    <span class="n">ENER</span><span class="o">=</span><span class="n">SENER</span><span class="o">+</span><span class="n">PENER</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;mbf&#39;</span><span class="p">:</span>
        <span class="n">C</span><span class="o">=</span><span class="n">ENER</span><span class="o">*</span><span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">-</span><span class="n">Def_grad</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">Piola_1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">C</span><span class="o">=</span><span class="n">ENER</span><span class="o">*</span><span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">-</span><span class="n">dU_dx</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">Piola_1</span>
    
    <span class="c1">#Caculate the inner part of the integral</span>
    <span class="n">C_Force</span><span class="o">=</span><span class="n">dN_dxyz</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">jacobi_det</span>
    
    <span class="c1">#generate_Code</span>
    <span class="n">expr_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s2">&quot;mbf&quot;</span><span class="p">:</span>
        <span class="n">expr_name</span><span class="o">=</span><span class="n">typ</span><span class="o">+</span><span class="s2">&quot;_mbf&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">expr_name</span><span class="o">=</span><span class="n">typ</span><span class="o">+</span><span class="s2">&quot;_dbf&quot;</span>
    
    <span class="n">impl</span><span class="o">=</span><span class="n">gen_Integration_C_static</span><span class="p">(</span><span class="n">rst</span><span class="p">,</span><span class="n">coord</span><span class="p">,</span><span class="n">Element_U</span><span class="p">,</span><span class="n">S_Ten</span><span class="p">,</span><span class="n">PENER</span><span class="p">,</span><span class="n">SENER</span><span class="p">,</span><span class="n">int_points</span><span class="p">,</span><span class="n">int_weights</span><span class="p">,</span><span class="n">C_Force</span><span class="p">,</span><span class="n">expr_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">impl</span></div>
    
    
<span class="c1">####### Dynamic Impementation ################################</span>
<div class="viewcode-block" id="gen_Configurational_Forces_Dynamic"><a class="viewcode-back" href="../../generated/Auxiliary_functions/ConF3D.Auxiliary_functions.gen_Configurational_Forces_Dynamic.html#ConF3D.Auxiliary_functions.gen_Configurational_Forces_Dynamic">[docs]</a><span class="k">def</span> <span class="nf">gen_Configurational_Forces_Dynamic</span><span class="p">(</span><span class="n">poly_power</span><span class="p">,</span><span class="n">bild_points</span><span class="p">,</span><span class="n">int_points</span><span class="p">,</span><span class="n">int_weights</span><span class="p">,</span><span class="n">typ</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates the dynamic configurational force implementation.</span>
<span class="sd">    This is a entry function and uses functions defined above to generate the numerical implementation </span>
<span class="sd">    of configurational forces for the dynamic case.</span>
<span class="sd">    All Inputs are defined in ele_def.py</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    poly_power : (at least number of nodes,3) nd-array</span>
<span class="sd">        Polynomial coefficents of shape functions in 3 dimensional space</span>
<span class="sd">    bild_points : (number of nodes,3) nd-array</span>
<span class="sd">        Natural coordinates of nodes</span>
<span class="sd">    int_points : (number of points, 3) nd-array</span>
<span class="sd">        Polynomial coefficents of shape functions in 3 dimensional space</span>
<span class="sd">    int_weights : (number of points) nd-array</span>
<span class="sd">        Integration weights</span>
<span class="sd">    typ : str</span>
<span class="sd">        Elementtype</span>
<span class="sd">    method : str (mbf/dbf)</span>
<span class="sd">        Motion based or displacement based formulation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    s : string</span>
<span class="sd">        Python code as string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#generate shape functions</span>
    <span class="n">shapeFuncCoef_bild</span><span class="p">,</span><span class="n">shapeFuncCoef_int</span><span class="p">,</span><span class="n">shapeFuncCoef_bild_diff</span><span class="p">,</span><span class="n">shapeFuncCoef_int_diff</span><span class="o">=</span>\
      <span class="n">generate_shape_func_coeff</span><span class="p">(</span><span class="n">bild_points</span><span class="p">,</span><span class="n">int_points</span><span class="p">,</span><span class="n">poly_power</span><span class="p">)</span>
    
    <span class="c1">#Generate some symbols</span>
    <span class="n">num_nodes</span>   <span class="o">=</span><span class="n">shapeFuncCoef_bild</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">num_int_points</span> <span class="o">=</span><span class="n">int_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">sy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;r s t&quot;</span><span class="p">)</span>
    <span class="n">rst</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
    <span class="n">coord</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">MatrixSymbol</span><span class="p">(</span><span class="s1">&#39;coord&#39;</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">Element_U</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">MatrixSymbol</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">SENER</span><span class="p">,</span><span class="n">PENER</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;SENER PENER&quot;</span><span class="p">)</span>
    <span class="n">S_Ten</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;S11 S22 S33 S12 S13 S23&quot;</span><span class="p">)</span>
    
    <span class="n">rho</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;rho&quot;</span><span class="p">)</span>
    <span class="n">Element_V</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">MatrixSymbol</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">Element_A</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">MatrixSymbol</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    
    <span class="c1">#Generate tensor, vaild for Abaqus notation</span>
    <span class="n">S</span><span class="o">=</span><span class="n">gen_2D_Ten_from_vec</span><span class="p">(</span><span class="n">S_Ten</span><span class="p">)</span>
    
    <span class="c1">#Generate Shape functions</span>
    <span class="n">shapeFunc</span><span class="o">=</span><span class="n">get_shapeFunc</span><span class="p">(</span><span class="n">shapeFuncCoef_bild</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
    
    <span class="c1">#Calculate Jacobi matrix</span>
    <span class="n">jac</span><span class="o">=</span><span class="n">get_jac</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">,</span><span class="n">coord</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
    
    <span class="c1">#Calculate inverse Jacobi matrix</span>
    <span class="n">jac_inv</span><span class="p">,</span><span class="n">jacobi_det</span><span class="o">=</span><span class="n">get_det_and_inv</span><span class="p">(</span><span class="n">jac</span><span class="p">)</span>
    
    <span class="c1">#calculate du/DX</span>
    <span class="n">Jacobi_Element_U</span><span class="o">=</span><span class="n">get_jac</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">,</span><span class="n">Element_U</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
    <span class="n">dU_dx</span><span class="o">=</span><span class="p">(</span><span class="n">jac_inv</span><span class="o">*</span><span class="n">Jacobi_Element_U</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1">#calculate dv/dx</span>
    <span class="n">Jacobi_Element_V</span><span class="o">=</span><span class="n">get_jac</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">,</span><span class="n">Element_V</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
    <span class="n">dV_dx</span><span class="o">=</span><span class="p">(</span><span class="n">jac_inv</span><span class="o">*</span><span class="n">Jacobi_Element_V</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1">#Calculate deformation gradient and time derivivative of deformation gradient</span>
    <span class="n">Def_grad</span><span class="o">=</span><span class="n">dU_dx</span><span class="o">+</span><span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">Def_grad_V</span><span class="o">=</span><span class="n">dV_dx</span> 
    
    <span class="c1">##################################################</span>
    <span class="c1">#Def_grad_mbf_dbf=Def_grad #mbf</span>
    <span class="n">Def_grad_mbf_dbf</span><span class="o">=</span><span class="n">dU_dx</span> <span class="c1">#dbf</span>
    <span class="c1">##################################################</span>
    <span class="c1">#Acceleration and Velocity with respect to r,s,t</span>
    <span class="n">acc</span><span class="o">=</span>     <span class="n">get_val_at_int_Pkt</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">,</span><span class="n">Element_A</span><span class="p">)</span>
    <span class="n">velocity</span><span class="o">=</span><span class="n">get_val_at_int_Pkt</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">,</span><span class="n">Element_V</span><span class="p">)</span>
    
    <span class="c1">#Calculate Pseudo momentum vector</span>
    <span class="n">P_m</span><span class="o">=-</span><span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">Def_grad_V</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">velocity</span><span class="o">+</span><span class="n">Def_grad_mbf_dbf</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">acc</span><span class="p">)</span>
    
    <span class="c1">#Calculate dN_dxyz </span>
    <span class="n">dN_rst</span><span class="o">=</span><span class="n">calc_dN_rst</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
    <span class="n">dN_dxyz</span><span class="o">=</span><span class="n">dN_rst</span><span class="o">*</span><span class="n">jac_inv</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1">#calculate 1st Piola Kirchhoff stress</span>
    <span class="n">Def_grad_inv</span><span class="p">,</span><span class="n">Def_grad_det</span><span class="o">=</span><span class="n">get_det_and_inv</span><span class="p">(</span><span class="n">Def_grad</span><span class="p">)</span>
    <span class="n">Piola_1</span><span class="o">=</span> <span class="n">Def_grad_det</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">Def_grad_inv</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1">#calculate kinetic energy density</span>
    <span class="n">T</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">velocity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">velocity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">velocity</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1">#Configurational Stress ermitteln</span>
    <span class="n">ENER</span><span class="o">=</span><span class="n">SENER</span><span class="o">+</span><span class="n">PENER</span>
    <span class="n">C</span><span class="o">=</span><span class="p">(</span><span class="n">ENER</span><span class="o">-</span><span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">-</span><span class="n">Def_grad_mbf_dbf</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">Piola_1</span>
    
    <span class="c1">#Caculate the inner part of the integral</span>
    <span class="n">C_Force</span><span class="o">=</span><span class="p">(</span><span class="n">shapeFunc</span><span class="o">*</span><span class="n">P_m</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="n">dN_dxyz</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">jacobi_det</span>
    
    <span class="c1">#generate_Code</span>
    <span class="n">impl</span><span class="o">=</span><span class="n">gen_Integration_C_dyn</span><span class="p">(</span><span class="n">rst</span><span class="p">,</span><span class="n">coord</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">Element_U</span><span class="p">,</span><span class="n">Element_V</span><span class="p">,</span><span class="n">Element_A</span><span class="p">,</span><span class="n">S_Ten</span><span class="p">,</span><span class="n">PENER</span><span class="p">,</span><span class="n">SENER</span><span class="p">,</span><span class="n">int_points</span><span class="p">,</span><span class="n">int_weights</span><span class="p">,</span><span class="n">C_Force</span><span class="p">,</span><span class="n">expr_name</span><span class="o">=</span><span class="n">typ</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">impl</span></div>

</pre></div>

          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2022, Markus Tauscher.
      </li>
      <li>
      Created using <a href="https://www.sphinx-doc.org">Sphinx</a> 3.0.3.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>