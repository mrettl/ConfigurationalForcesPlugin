<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>Symbolic implementation of configurational forces &mdash; ConF3D 0.1 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="_static/css/spc-extend.css">
    <link rel="stylesheet" href="_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="genindex.html" >
    <link rel="search" title="Search" href="search.html" >
    <link rel="top" title="ConF3D 0.1 documentation" href="index.html" >
    <link rel="prev" title="Element Definitions" href="generated/ele_def.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="index.html">ConF3D 0.1 documentation</a></li>
	 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
      <li class="active">
        <a href="generated/ele_def.html" title="Element Definitions"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="symbolic-implementation-of-configurational-forces">
<span id="example"></span><h1>Symbolic implementation of configurational forces<a class="headerlink" href="#symbolic-implementation-of-configurational-forces" title="Permalink to this headline">Â¶</a></h1>
<p><span class="math notranslate nohighlight">\(\newcommand{\mytensor}[1] {\boldsymbol{\mathrm{#1}}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\myjaci}[2]   {\displaystyle \sum^i\frac{\partial \mathrm{N}^{\,i}}{\partial #2} #1^{\,i}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\mynderiv}[2] {\displaystyle \frac{\partial\mathrm{N}^{#1}}{\partial\mathrm{r}_{#2}}}\)</span></p>
<p>In the following, the main part of the derivation of configurational forces implementation for the elastic and elastic-plastic is shown.
Configurational forces <span class="math notranslate nohighlight">\(\mytensor{g}\)</span> are defined depending on the shape functions <span class="math notranslate nohighlight">\(\mytensor{N}\)</span>, the cartesian coordinates <span class="math notranslate nohighlight">\(\mytensor{x}\)</span>,
the configurational stress <span class="math notranslate nohighlight">\(\mytensor{C}\)</span> and the Jacobi determinant <span class="math notranslate nohighlight">\(\det\left(\mytensor{J}\right)\)</span> in the following way:</p>
<p><span class="math notranslate nohighlight">\(\mytensor{g}=\int_{V}{\frac{\partial\mytensor{N}}{\partial\mytensor{x}}{\mytensor{C}}^\mathrm{T}}\det\left(\mytensor{J}\right)dV\)</span></p>
<p>In this formula the inner part of the integral must be derived symbolically, the integration is than performed using a automatically generated
Gauss integration routine. This derivation is shown in detail in the following sections. At the end numeric code is generated for all supported elements.</p>
<p>For clarification each section contains the corresponding code snippets and formulas.</p>
<p><strong>Calculation of the shape function coefficients</strong></p>
<p>The elements are defined by their nodal coordinates and integration points in the natural coordinate system.
Shape functions are defined by the occuring polynomial exponents. Therefore, the coefficients of the shape functions have
to be derived. Note that the node ordering of an element is Abaqus-specific needs to be adapted for different FEM-solvers.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">shapeFuncCoef_bild</span><span class="p">,</span><span class="n">shapeFuncCoef_int</span><span class="p">,</span><span class="n">shapeFuncCoef_bild_diff</span><span class="p">,</span><span class="n">shapeFuncCoef_int_diff</span><span class="o">=</span>\
<span class="gp">&gt;&gt;&gt; </span><span class="n">generate_shape_func_coeff</span><span class="p">(</span><span class="n">bild_points</span><span class="p">,</span><span class="n">int_points</span><span class="p">,</span><span class="n">poly_power</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Definitions of neccesary symbols</strong></p>
<p>In this section, all necessary symbols are defined. Note that this definition also specifies the way in which the FE-results have to be passed to
the generated functions. For example, the order of the stress vector can be stated in this code segment.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num_nodes</span>      <span class="o">=</span> <span class="n">shapeFuncCoef_bild</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_int_points</span> <span class="o">=</span> <span class="n">int_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span>        <span class="o">=</span> <span class="n">sy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;r s t&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rst</span>            <span class="o">=</span> <span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coord</span>          <span class="o">=</span> <span class="n">sy</span><span class="o">.</span><span class="n">MatrixSymbol</span><span class="p">(</span><span class="s1">&#39;coord&#39;</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Element_U</span>      <span class="o">=</span> <span class="n">sy</span><span class="o">.</span><span class="n">MatrixSymbol</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SENER</span><span class="p">,</span><span class="n">PENER</span>    <span class="o">=</span> <span class="n">sy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;SENER PENER&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S_Ten</span>          <span class="o">=</span> <span class="n">sy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;S11 S22 S33 S12 S13 S23&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Generation of shape functions</strong></p>
<p>The shape functions <span class="math notranslate nohighlight">\(\mytensor{N}\)</span> in symbolic represenation depending on the natural coordinates vector <span class="math notranslate nohighlight">\(\mytensor{r}\)</span> with its components <span class="math notranslate nohighlight">\(r \, s \, t\)</span>,
are generated from their coefficients. Of course, the shape functions can be also directly
provided at this point, but this would be more error-prone and less user user-friendly.</p>
<p><span class="math notranslate nohighlight">\(\mytensor{N}=\left[\begin{array}{ccc}\mathrm{N}^1 \\ \vdots \\ \mathrm{N}^i \end{array}\right]\)</span></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">shapeFunc</span><span class="o">=</span><span class="n">get_shapeFunc</span><span class="p">(</span><span class="n">shapeFuncCoef_bild</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Calculation of the Jacobi matrix</strong></p>
<p>The Jacobi matrix <span class="math notranslate nohighlight">\(\mytensor{J}\)</span> is calculated as shown in the following formula. The <span class="math notranslate nohighlight">\(\mytensor{r}\)</span> vector represents the natural coordinates of a node,
the <span class="math notranslate nohighlight">\(\mytensor{x}\)</span> vector represents the global coordinates.
Additionally, the inverse jacobian matrix and the jacobi determinant is calculated.</p>
<p><span class="math notranslate nohighlight">\(\mytensor{J}= \left[\begin{array}{cccc} \myjaci{x_1}{r_1} &amp;  \myjaci{x_2}{r_1} &amp;  \myjaci{x_3}{r_1} \\ \myjaci{x_1}{r_2} &amp;  \myjaci{x_2}{r_2} &amp;  \myjaci{x_3}{r_2} \\ \myjaci{x_1}{r_3} &amp;  \myjaci{x_2}{r_3} &amp;  \myjaci{x_3}{r_3} \\ \end{array} \right]\)</span></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jac</span> <span class="o">=</span> <span class="n">get_jac</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">,</span><span class="n">coord</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jac_inv</span><span class="p">,</span><span class="n">jacobi_det</span> <span class="o">=</span> <span class="n">get_det_and_inv</span><span class="p">(</span><span class="n">jac</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Determining the derivivative of the displacements with respect to</strong> <span class="math notranslate nohighlight">\(\mytensor{x}\)</span> <strong>and deformation gradient</strong></p>
<p>At first, the derivivative of the nodal displacements <span class="math notranslate nohighlight">\(\mytensor{u}\)</span> with respect to the natural coordinates <span class="math notranslate nohighlight">\(\mytensor{r}\)</span> is calculated simmilar to the Jacobi matrix above.</p>
<p><span class="math notranslate nohighlight">\(\displaystyle \frac{\partial\mytensor{u}}{\partial\mytensor{r}}= \left[\begin{array}{cccc} \myjaci{u_1}{r_1} &amp;  \myjaci{u_2}{r_1} &amp;  \myjaci{u_3}{r_1} \\ \myjaci{u_1}{r_2} &amp;  \myjaci{u_2}{r_2} &amp;  \myjaci{u_3}{r_2} \\ \myjaci{u_1}{r_3} &amp;  \myjaci{u_2}{r_3} &amp;  \myjaci{u_3}{r_3} \\ \end{array} \right]\)</span></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Jacobi_Element_U</span><span class="o">=</span><span class="n">get_jac</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">,</span><span class="n">Element_U</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, the derivivative of the displacement <span class="math notranslate nohighlight">\(\mytensor{u}\)</span> with respect to <span class="math notranslate nohighlight">\(\mytensor{x}\)</span> can be calculated.</p>
<p><span class="math notranslate nohighlight">\(\displaystyle \frac{\partial\mytensor{u}}{\partial\mytensor{x}}= \left ( \mytensor{J^{-1}} \displaystyle \frac{\partial\mytensor{u}}{\partial\mytensor{r}} \right )^\mathrm{T}\)</span></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dU_dx</span><span class="o">=</span><span class="p">(</span><span class="n">jac_inv</span><span class="o">*</span><span class="n">Jacobi_Element_U</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
<p>The deformation gradient <span class="math notranslate nohighlight">\(\mytensor{F}\)</span> is defined by the following equation, with <span class="math notranslate nohighlight">\(\mytensor{I}\)</span> as the idenedity matrix.</p>
<p><span class="math notranslate nohighlight">\(\mytensor{F} = \mytensor{I}+\displaystyle \frac{\partial\mytensor{u}}{\partial\mytensor{x}}\)</span></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Def_grad</span><span class="o">=</span><span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">+</span><span class="n">dU_dx</span>
</pre></div>
</div>
<p><strong>Determining the derivivative of the shape functions</strong> <span class="math notranslate nohighlight">\(\mytensor{N}\)</span> <strong>with respect to</strong> <span class="math notranslate nohighlight">\(\mytensor{x}\)</span> <strong>from</strong> <span class="math notranslate nohighlight">\(\displaystyle \frac{\partial\mytensor{N}}{\partial\mytensor{r}}\)</span> <strong>and the Jabobian</strong></p>
<p><span class="math notranslate nohighlight">\(\displaystyle \frac{\partial\mytensor{N}}{\partial\mytensor{r}} = \left[\begin{array}{cccc} \mynderiv{1}{1} &amp; \mynderiv{1}{2} &amp; \mynderiv{1}{3} \\ \vdots &amp; \vdots &amp; \vdots \\ \mynderiv{i}{1} &amp; \mynderiv{i}{2} &amp;  \mynderiv{i}{3} \end{array} \right]\)</span></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dN_rst</span><span class="o">=</span><span class="n">calc_dN_rst</span><span class="p">(</span><span class="n">shapeFunc</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(\displaystyle \frac{\partial\mytensor{N}}{\partial\mytensor{x}} = \displaystyle \frac{\partial\mytensor{N}}{\partial\mytensor{r}} \mytensor{J}^\mathrm{-T}\)</span></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dN_dxyz</span><span class="o">=</span><span class="n">dN_rst</span><span class="o">*</span><span class="n">jac_inv</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
<p><strong>Calculation of the first Piola Kirchhoff stress</strong></p>
<p>The first Piola Kirchhoff stress <span class="math notranslate nohighlight">\(\mytensor{P}\)</span> is calculated from the the chauchy stress <span class="math notranslate nohighlight">\(\mytensor{S}\)</span> and the deformation gradient <span class="math notranslate nohighlight">\(\mytensor{F}\)</span> by the following equation.</p>
<p><span class="math notranslate nohighlight">\(\mytensor{P} = \mathrm{det}(\mytensor{F}) \, \mytensor{S} \,\mytensor{F}^{-T}\)</span></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">=</span><span class="n">gen_2D_Ten_from_vec</span><span class="p">(</span><span class="n">S_Ten</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Def_grad_inv</span><span class="p">,</span><span class="n">Def_grad_det</span><span class="o">=</span><span class="n">get_det_and_inv</span><span class="p">(</span><span class="n">Def_grad</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Piola_1</span><span class="o">=</span> <span class="n">Def_grad_det</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">Def_grad_inv</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
<p><strong>Calculation of the configurational stress</strong></p>
<p>The configurational stress <span class="math notranslate nohighlight">\(\mytensor{C}\)</span> can be writen in a motion-based and a deformation-based formulation. Both are supported by this package.
The energy density <span class="math notranslate nohighlight">\(\phi\)</span> represents the sum of the plastic energy density <span class="math notranslate nohighlight">\(\phi_\mathrm{pl}\)</span> and the strain energy density <span class="math notranslate nohighlight">\(\phi_\mathrm{el}\)</span>.
In the script which generates the numerical implementations for all supported element types, both the motion based and the deformation based formulations are generated.
In the interface they can be selected by the parameter <code class="xref py py-func docutils literal notranslate"><span class="pre">method()</span></code>.</p>
<p><span class="math notranslate nohighlight">\(\phi = \phi_\mathrm{pl} + \phi_\mathrm{el}\)</span></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ENER</span> <span class="o">=</span> <span class="n">SENER</span><span class="o">+</span><span class="n">PENER</span>
</pre></div>
</div>
<p>The motion-based formulation defines the configurational stress <span class="math notranslate nohighlight">\(\mytensor{C}\)</span> depending on the energy density <span class="math notranslate nohighlight">\(\phi\)</span>, the idendity matrix <span class="math notranslate nohighlight">\(\mytensor{I}\)</span>,
the deformation gradient <span class="math notranslate nohighlight">\(\mytensor{F}\)</span> and the first Piola Kirchhoff stress <span class="math notranslate nohighlight">\(\mytensor{P}\)</span>.</p>
<p><span class="math notranslate nohighlight">\(\mytensor{C} = \mathrm{\phi} \, \mytensor{I} - \mytensor{F}^\mathrm{T} \, \boldsymbol{\mathrm{P}}\)</span></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ENER</span><span class="o">*</span><span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">-</span><span class="n">Def_grad</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">Piola_1</span>
</pre></div>
</div>
<p>The displacement-based formulation defines the configurational stress <span class="math notranslate nohighlight">\(\mytensor{C}\)</span> depending on the energy density <span class="math notranslate nohighlight">\(\phi\)</span>, the idendity matrix <span class="math notranslate nohighlight">\(\mytensor{I}\)</span>,
<span class="math notranslate nohighlight">\(\displaystyle \frac{\partial\mytensor{u}}{\partial\mytensor{x}}\)</span> and the first Piola Kirchhoff stress <span class="math notranslate nohighlight">\(\mytensor{P}\)</span>.</p>
<p><span class="math notranslate nohighlight">\(\mytensor{C} = \mathrm{\phi} \, \mytensor{I} - \displaystyle \left (\frac{\partial\mytensor{u}}{\partial\mytensor{x}} \right)^\mathrm{T} \, \boldsymbol{\mathrm{P}}\)</span></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ENER</span><span class="o">*</span><span class="n">sy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">-</span><span class="n">dU_dx</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">Piola_1</span>
</pre></div>
</div>
<p><strong>Determining inner part of the configurational force integral</strong></p>
<p>The inner part of the volume integral in a symbolic definition, shown in the beginning, represents the final result of the derivation.
By calling the function <code class="code docutils literal notranslate"><span class="pre">lambdify_C</span></code>, a numerical implementation can be generated.</p>
<p><span class="math notranslate nohighlight">\(\mytensor{f} = \displaystyle \frac{\partial\mytensor{N}}{\partial\mytensor{x}} \, \mytensor{C}^\mathrm{T} \, \mathrm{det}(\mytensor{J})\)</span></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C_Force</span><span class="o">=</span><span class="n">dN_dxyz</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">jacobi_det</span>
</pre></div>
</div>
<p><strong>Generate the Implementation</strong></p>
<p>The function <code class="xref py py-func docutils literal notranslate"><span class="pre">gen_Integration_C_static()</span></code> generates two C-functions. In the first step <code class="xref py py-func docutils literal notranslate"><span class="pre">lambdify_C()</span></code> is called to generate a numerical implementation of the provided expression.
In the second step a function to numerically integrate the expression is generated.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">impl</span><span class="o">=</span><span class="n">gen_Integration_C_static</span><span class="p">(</span><span class="n">rst</span><span class="p">,</span><span class="n">coord</span><span class="p">,</span><span class="n">Element_U</span><span class="p">,</span><span class="n">S_Ten</span><span class="p">,</span><span class="n">PENER</span><span class="p">,</span><span class="n">SENER</span><span class="p">,</span><span class="n">int_points</span><span class="p">,</span><span class="n">int_weights</span><span class="p">,</span><span class="n">C_Force</span><span class="p">,</span><span class="n">expr_name</span><span class="p">)</span>
</pre></div>
</div>
</div>


          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="generated/ele_def.html"
                        title="previous chapter">Element Definitions</a></p>
  <h3>This Page</h3>
  <div>
    <a href="_sources/Example.rst.txt"
       rel="nofollow">Show Source</a>
  </div>
        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2022, Markus Tauscher.
      </li>
      <li>
      Created using <a href="https://www.sphinx-doc.org">Sphinx</a> 3.0.3.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>